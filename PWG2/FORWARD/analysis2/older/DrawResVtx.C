#include "DrawRes1D.C"

/** 
 * @defgroup pwg2_forward_analysis_scripts PWG2 Forward analysis - scripts
 *
 * @ingroup pwg2_forward_analysis
 */
/** 
 * Example macro to loop over the event-by-event 2D histogram of 
 * @f[
 *   \frac{d^{2}N_{ch}}{d\eta\,d\phi}
 * @f]
 * stored in an AOD.  
 * 
 * The class needs the files &lt;<i>base</i>&gt;<tt>_hists.root</tt> 
 * containing the histograms generated by AliForwardMultiplicity and 
 * the file &lt;<i>base</i>&gt;<tt>_aods.root</tt> containing the tree 
 * with AliAODEvent objects where AliAODForwardMult objects have been 
 * added to in the branch <tt>Forward</tt>
 * 
 * @ingroup pwg2_forward_analysis_scripts
 */
class DrawResVtx : public DrawRes1D
{
public:
  /** 
   * Constructor 
   * 
   * @param special If true, add to the list of 'specials'
   */
  DrawResVtx()
    : fByVtx1D(0)
  {}
  //__________________________________________________________________
  /** 
   * Open the files &lt;<i>base</i>&gt;<tt>_hists.root</tt> 
   * containing the histograms generated by AliForwardMultiplicity and 
   * the file &lt;<i>base</i>&gt;<tt>_aods.root</tt> containing the tree 
   * with AliAODEvent objects.
   * 
   * @param base  Base name of files 
   * @param vzMin Minimum collision vertex z position to use
   * @param vzMax Maximum collision vertex z position to use
   * @param rebin Rebinning factor 
   * 
   * @return true on success, false otherwise 
   */
  Bool_t Open(const char* base, 
	      Double_t    vzMin=-10, 
	      Double_t    vzMax=10)
  {
    // Clear previously created data objects 
    fByVtx1D.Delete();
    return DrawRes1D::Open(base, vzMin, vzMax);
  }

  //__________________________________________________________________
  /** 
   * Make a 1D histogram of @f$ dN_{ch}/d\eta@f$ with the given name and 
   * title 
   * 
   * @param name   Name of histogram 
   * @param title  Title of histogram 
   * @param a1     Eta axis 
   * 
   * @return Newly allocated 1D histogram object 
   */
  TH1D* Make1D(const char* name, const char* title, const TAxis* a1)
  {
    TH1D* ret = new TH1D(name, title,
			 a1->GetNbins(), a1->GetXmin(), a1->GetXmax());
    ret->SetXTitle("#eta");
    ret->SetYTitle("#frac{1}{N}#frac{dN_{ch}}{d#eta}");
    ret->Sumw2();
    ret->SetMarkerColor(kRed+1);
    ret->SetLineColor(kRed+1);
    ret->SetMarkerStyle(20);
    ret->SetMarkerSize(1);
    ret->SetStats(0);
    ret->SetDirectory(0);

    return ret;
  }
  //__________________________________________________________________
  /** 
   * Utility function to set-up histograms based on the input 
   * @f$ dd^{2}N_{ch}/d\eta\,d\phi@f$ histogram.   This member function 
   * is called on the first event so that we have the proper binning 
   * 
   * @param templ Input histogram
   * 
   * @return true on succcess
   */
  Bool_t FirstEvent(const TH2D& templ) 
  { 
    if (!DrawRes1D::FirstEvent(templ)) return kFALSE;

    const TAxis* etaAxis = templ.GetXaxis();
    
    // Generate the per-vertex bin histograms.  These will be the sum 
    // of each of the per-event input histograms for a given vertex range. 
    for (Int_t i = fBinVzMin; i <= fBinVzMax; i++) { 
      TH1* h1 = Make1D(Form("dndeta_vz%02d", i), 
		       Form("#frac{1}{N}#frac{dN_{ch}}{d#eta}, vtxbin=%d", i),
		       etaAxis);
      fByVtx1D.AddAtAndExpand(h1, i);
    }
    return kTRUE;
  }


  //__________________________________________________________________
  /** 
   * Process the events 
   * 
   * 
   * @return true on success, false otherwise 
   */
  void AddContrib(const TH2D& hist, Int_t vtxBin)
  {
    // Get 'by-vertex' histograms 
    TH1* tmp1 = static_cast<TH1D*>(fByVtx1D.At(vtxBin));
    if (!tmp1) { 
      Warning("Process", "No histogram for vertex bin %d)",vtxBin);
      return;
    }
    // Make a projection on the X axis of the input histogram 
    TH1D*    proj  = hist.ProjectionX("_px", 0, -1, "e");
    
    // Add to per-vertex histogram 
    tmp1->Add(proj); 
    
    delete proj;
  } 
  //__________________________________________________________________
  /** 
   * Called at the end of the job. 
   *
   * It plots the result of the analysis in tree canvases.   
   * - One shows the per-vertex accumalted histograms and compares them 
   *   to the per-vertex histograms made in the analysis. 
   * - Another shows the final @f$ dN_{ch}/d\eta@f$ calculated in 
   *   different ways and compare those to the  @f$ dN_{ch}/d\eta@f$ made 
   *   during the analysis. 
   * - The last canvas shows the @f$ dd^{2}N_{ch}/d\eta\,d\phi@f$ histogram. 
   * 
   * @return true on succes, false otherwise 
   */
  TH1D* GetResult() 
  {
    // Get number of bins 
    Int_t nBin = fBinVzMax-fBinVzMin+1;

    // Make first canvas 
    TCanvas* cVtx = new TCanvas("cVtx", "By Vertex", 1000, 700);
    cVtx->SetBorderSize(0);
    cVtx->SetBorderMode(0);
    cVtx->Divide((nBin+.5)/2, 2, 0.0005, 0.0005);

    // Loop over vertex histograms 
    TDirectory* savdir = gDirectory;
    for (Int_t i = fBinVzMin; i <= fBinVzMax; i++) { 
      TDirectory* vtxDir = savdir->mkdir(Form("vtx%02d", i));
      vtxDir->cd();

      TH1D* vh1 = static_cast<TH1D*>(fByVtx1D.At(i));
      if (!vh1) { 
	Error("Finish", "No histogram at %d", i);
	continue;
      }
      
      fTotal1D->Add(vh1);

      // Scale and add to output 
      if (fVtx->GetBinContent(i) > 0)
	vh1->Scale(1. / fVtx->GetBinContent(i), "width");

      // Write to output file 
      vh1->Write(); 

      // Divide the pad
      TVirtualPad* pad = cVtx->cd(i-fBinVzMin+1);
      pad->Divide(1,2,0.005,0);
      
      // Draw the per-vertex histogram 
      pad->cd(1);
      vh1->DrawClone();
      
      // Get the same histogram from the analysis and draw it 
      TProfile* p = 
	static_cast<TProfile*>(fCollect
			       ->FindObject(Form("dndeta_vtx%02d",i-1)));
      p->SetMarkerColor(kBlue+1);
      p->SetLineColor(kBlue+1);
      p->SetMarkerSize(0.8);
      p->SetMarkerStyle(20);
      p->DrawClone("same");
      p->Write();

      // Make the ratio of the two histograms and draw it 
      pad->cd(2);
      TH1* ratio = static_cast<TH1*>(vh1->Clone(Form("ratio_vtx%02d", i-1)));
      // ratio->Scale(1./fEvents->GetBinContent(i));
      ratio->Divide(p);
      ratio->SetMarkerSize(.8);
      ratio->SetLineColor(kGray);
      ratio->DrawClone("P");
    }
    cVtx->cd();
    savdir->cd();

    // Scale the histogram summed over the vertex bins.  This must be 
    // divided by the number of bins we have summed over.  If we do 
    // rebinning, we should scale it again. 
    fTotal1D->Divide(fNorm);
    fTotal1D->Scale(1, "width"); 
    return fTotal1D;
  }
  /** 
   * Browse this object 
   * 
   * @param b Browser to use 
   */
  void Browse(TBrowser* b) 
  {
    b->Add(&fByVtx1D);
    DrawRes1D::Browse(b);
  }
  /** 
   * Create a new object of this class, and add it to the list of 
   * specials, and create a browse and browse to this object 
   * 
   * @return Newly created object
   */
  static DrawResVtx* Create() 
  {
    DrawResVtx* dr = new DrawResVtx;
    gROOT->GetListOfSpecials()->Add(dr);
    TBrowser* b = new TBrowser("b");
    b->BrowseObject(gROOT->GetListOfSpecials());
    return dr;
  }

protected:
  TObjArray          fByVtx1D;   // List of per-vertex 1D histograms

  ClassDef(DrawResVtx,0)
};

//
// EOF
//
