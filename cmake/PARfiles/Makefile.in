# Makefile for @PARMODULE@ -- automatically generated

# From ROOT
include Makefile.arch

# Name of this module
PAR_MODULE := @PARMODULE@

# This module depends on the following libraries
PAR_LIBDEPS := @PARLIBDEPS@

# Include paths
PAR_INCLUDES = -I. -I$(ALICE_ROOT)/include -I$(ALICE_PHYSICS)/include -I$(ROOTSYS)/include

# Get C++ flags form ROOT
PAR_CXXFLAGS = $(CXXFLAGS) $(PAR_INCLUDES)

#Â Get linker flags from ROOT
PAR_SOFLAGS = $(SOFLAGS) $(LDFLAGS)

# Exclude generated dictionaries from the list of sources
SRCS := $(filter-out $(wildcard G__*.cxx),$(wildcard *.cxx))

HDRS := $(SRCS:.cxx=.h)
DHDR := $(PAR_MODULE)LinkDef.h

SRCS += G__$(PAR_MODULE).cxx
OBJS := $(SRCS:.cxx=.o)

COLM := \033[35m
COLC := \033[36m
COLG := \033[32m
COLZ := \033[m

# Default rule (it's the first one, "all" is just a convention)
all: lib$(PAR_MODULE).rootmap lib$(PAR_MODULE).so
	@echo -e "[$(COLM)$(PAR_MODULE)$(COLZ)] $(COLG)PARfile built successfully$(COLZ)"

# Abstract rule to compile classes to objects
%.o: %.cxx %.h
	@echo -e "[$(COLM)$(PAR_MODULE)$(COLZ)] compiling $(COLC)$<$(COLZ)"
	@$(CXX) $(PAR_CXXFLAGS) -c $< -o $@

# Generate library from objects
lib$(PAR_MODULE).so: $(OBJS)
	@echo -e "[$(COLM)$(PAR_MODULE)$(COLZ)]" building shared library
	@$(LD) $(PAR_SOFLAGS) $^ -o $@ $(EXPLLINKLIBS)

# Generate dictionary (rule broken up to accommodate parallel builds)
G__$(PAR_MODULE).h: G__$(PAR_MODULE).cxx

G__$(PAR_MODULE).cxx: $(HDRS) $(DHDR)
	@echo -e "[$(COLM)$(PAR_MODULE)$(COLZ)]" generating dictionary
	@rootcint -f $@ -c -p $(PAR_INCLUDES) $^

# Generate rootmap (for automatic loading of libraries)
lib$(PAR_MODULE).rootmap: lib$(PAR_MODULE).so
	@echo -e "[$(COLM)$(PAR_MODULE)$(COLZ)]" generating rootmap
	@rlibmap -o $@ -l lib$(PAR_MODULE) -d $(PAR_LIBDEPS) -c $(DHDR)

# Delete all
clean:
	rm -f $(OBJS) *.so G__$(PAR_MODULE).* *.rootmap
