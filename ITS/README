1. Introduction
---------------

Dear ITS (and ALICE) user,

     This is a short help on how to run the ITS simulation/reconstruction code 
within the AliRoot framework. It is NOT intended as a comprehensive user's 
guide and eventually it will be updated in the ITS Manual which is on its way 
to be written. What follows requires that the you already know how to download,
install and compile the AliRoot package. This file explains how to set the 
proper ITS geometry and how to tun the test macros contained under the 
directory ITS in order to compare your own installation with the standard one 
looking at some distributions/histograms.
        Any difference between what is described here and what you really get
when you  run the code on your computer must be reported either to Roberto
Barbera at roberto.barbera@ct.infn.it or to Bjorn Nilsen at
nilsen@mps.ohio-state.edu. Please note that all the tests described here have
been done on a PC running Linux RedHat 6.1, gcc 2.95.2, and Root 3.00/06. If
you have different hardware/software configuration, please add it to all bug
reports.


2. Set the ITS geometry you want to use
---------------------------------------

In order to set one of the many ITS geometries available, you have to modify 
the ITS part in the file Config.C under the directory macros (you have to
modify the file ConfigPPR.C if you want to run full 'PPR' events). The default
ITS part of Config.C (or ConfigPPR.C) is reported here:

  if(iITS) {

//=================== ITS parameters ============================
    //
    // As the innermost detector in ALICE, the Inner Tracking System "impacts"
    // on almost all other detectors. This involves the fact that the ITS
    // geometry  still has several options to be followed in parallel in order
    // to determine the best set-up which minimizes the induced background. All
    // the geometries available to date are described in the following. Read
    // carefully the comments and use the default version (the only one
    // uncommented) unless you are making comparisons and you know what you are
    // doing. In this case just uncomment the ITS geometry you want to use and
    // run Aliroot.
    //
    // Detailed geometries:         
    //
    //
    //AliITS *ITS  = new AliITSv5symm("ITS","Updated ITS TDR detailed version with symmetric services");
    //
    AliITS *ITS  = new AliITSv5asymm("ITS","Updates ITS TDR detailed version with asymmetric services");
    //
    //AliITSvPPRasymm *ITS  = new AliITSvPPRasymm("ITS","New ITS PPR detailed version with asymmetric services");
    //ITS->SetMinorVersion(2);
    //ITS->SetReadDet(kFALSE);
    //ITS->SetWriteDet("$ALICE_ROOT/ITS/ITSgeometry_vPPRasymm2.det");
    //ITS->SetThicknessDet1(300.);   // detector thickness on layer 1 must be in the range [100,300]
    //ITS->SetThicknessDet2(300.);   // detector thickness on layer 2 must be in the range [100,300]
    //ITS->SetThicknessChip1(300.);  // chip thickness on layer 1 must be in the range [150,300]
    //ITS->SetThicknessChip2(300.);  // chip thickness on layer 2 must be in the range [150,300]
    //ITS->SetRails(1);            // 1 --> rails in ; 0 --> rails out
    //ITS->SetCoolingFluid(1);     // 1 --> water ; 0 --> freon
    //
    //AliITSvPPRsymm *ITS  = new AliITSvPPRsymm("ITS","New ITS PPR detailed version with symmetric services");
    //ITS->SetMinorVersion(2);                                      
    //ITS->SetReadDet(kFALSE);
    //ITS->SetWriteDet("$ALICE_ROOT/ITS/ITSgeometry_vPPRsymm2.det");
    //ITS->SetThicknessDet1(300.);   // detector thickness on layer 1 must be in the range [100,300]
    //ITS->SetThicknessDet2(300.);   // detector thickness on layer 2 must be in the range [100,300]
    //ITS->SetThicknessChip1(300.);  // chip thickness on layer 1 must be in the range [150,300]
    //ITS->SetThicknessChip2(300.);  // chip thickness on layer 2 must be in the range [150,300]
    //ITS->SetRails(1);              // 1 --> rails in ; 0 --> rails out
    //ITS->SetCoolingFluid(1);       // 1 --> water ; 0 --> freon
    //
    //
    // Coarse geometries (warning: no hits are produced with these coarse geometries and they unuseful 
    // for reconstruction !):
    //                                                     
    //
    //AliITSvPPRcoarseasymm *ITS  = new AliITSvPPRcoarseasymm("ITS","New ITS coarse version with asymmetric services");
    //ITS->SetRails(1);                // 1 --> rails in ; 0 --> rails out
    //ITS->SetSupportMaterial(0);      // 0 --> Copper ; 1 --> Aluminum ; 2 --> Carbon
    //
    //AliITS *ITS  = new AliITSvPPRcoarsesymm("ITS","New ITS coarse version with symmetric services");
    //ITS->SetRails(1);                // 1 --> rails in ; 0 --> rails out
    //ITS->SetSupportMaterial(0);      // 0 --> Copper ; 1 --> Aluminum ; 2 --> Carbon
    //                      
    //
    //
    // Geant3 <-> EUCLID conversion
    // ============================
    //
    // SetEUCLID is a flag to output (=1) or not to output (=0) both geometry
    // and  media to two ASCII files (called by default ITSgeometry.euc and
    // ITSgeometry.tme) in a format understandable to the CAD system EUCLID.
    // The default (=0) means that you dont want to use this facility.
    //
    ITS->SetEUCLID(0);  
  }
  
As you can see looking at the uncommented line, the present default is

    AliITS *ITS  = new AliITSv5asymm("ITS","Updates ITS TDR detailed version with
asymmetric services"); 
    
which is the TDR detailed geometry with asymmetric services. If you want to run
the TDR detailed version with symmetric services, You have to uncomment this
line and comment out the line above.

    AliITS *ITS  = new AliITSv5symm("ITS","Updated ITS TDR detailed version with
symmetric services");

If you want to run the new PPR coarse geometry with asymmetric services, You
have to uncomment this line and comment out the line above.

    AliITSvPPRcoarseasymm *ITS  = new AliITSvPPRcoarseasymm("ITS","New ITS coarse
version with asymmetric services");
    ITS->SetRails(1);                // 1 --> rails in ; 0 --> rails out
    ITS->SetSupportMaterial(0);      // 0 --> Copper ; 1 --> Aluminum ; 2 --> Carbon

There are two functions shown above. The first set the ITS rails in (=1) or out
(=0) (the default is in). If the switch for rails is different from 0 and 1 a
warning message is printed out and the default (rails in) is used. The second
changes the material of the supports to the ITS services': copper (=0, which is
the default), aluminum (=1), and  carbon (=2). If the switch of the support
material is different from 0, 1 and 2, a warning message is printed out and the
default (copper) is used. Note the the thickness of the supports is always the
same so the situation is completely unrealistic. This is because there has been
no attempt to change the geometry of this material as would be needed for the
support to realy support the serveces. The possibility to  change this material
has been explicitly requested by the PMD group to allow them to study the
effect of this material on their detector.

If you want to run the new PPR coarse geometry with symmetric services, you
have to uncomment these lines and comment out the above lines.

    AliITS *ITS  = new AliITSvPPRcoarsesymm("ITS","New ITS coarse version with
symmetric services");
    ITS->SetRails(1);                // 1 --> rails in ; 0 --> rails out
    ITS->SetSupportMaterial(0);      // 0 --> Copper ; 1 --> Aluminum ; 2 --> Carbon

The two additional functions are just the same of those described above.

    If you want to run the new PPR detailed geometry with asymmetric services,
you have to uncomment these lines and comment out the above lines.

    AliITSvPPRasymm *ITS  = new AliITSvPPRasymm("ITS","New ITS PPR detailed version
with asymmetric services");
    ITS->SetMinorVersion(2);
    ITS->SetReadDet(kFALSE);
    ITS->SetWriteDet("$ALICE_ROOT/ITS/ITSgeometry_vPPRasymm2.det");
    ITS->SetThicknessDet1(300.);   // detector thickness on layer 1 must be in the
range [100,300]
    ITS->SetThicknessDet2(300.);   // detector thickness on layer 2 must be in the
range [100,300]
    ITS->SetThicknessChip1(300.);  // chip thickness on layer 1 must be in the range
[150,300]
    ITS->SetThicknessChip2(300.);  // chip thickness on layer 2 must be in the range
[150,300]
    ITS->SetRails(1);              // 1 --> rails in ; 0 --> rails out
    ITS->SetCoolingFluid(1);       // 1 --> water ; 0 --> freon

    The first three functions are reserved to the ITS developpers and their
values must not be modified at any time. The next four functions allow the user
to  change the thickness of detectors and chips in the two SPD layers
separately.  Detector thicknesses can go from 100 microns (TDR value) to 300
microns (present default value). If a value outside this range is set a warning
message is printed out and the default value (300 microns) is used. Chip
thicknesses can go from 150 (TDR value) to 300 (present default value)
microns. If a value outside this range is set a warning message is printed out
and the default value (300 microns) is used. The last two function allow people
to set the ITS rails in (=1) and out (=0) (the default is in) and the cooling
fluid as water (=1, which is the default) or freon (=0). If the switch for
rails is different from 0 and 1 a warning message is printed out and the
default (rails in) is used. If the switch of the cooling fluid is different
from 0 and 1 a warning message is printed out and the default (water) is used.

     If you want to run the new PPR detailed geometry with symmetric services,
the only uncommented lines must be:

    AliITSvPPRsymm *ITS  = new AliITSvPPRsymm("ITS","New ITS PPR detailed version
with symmetric services");
    ITS->SetMinorVersion(2);                                      
    ITS->SetReadDet(kFALSE);
    ITS->SetWriteDet("$ALICE_ROOT/ITS/ITSgeometry_vPPRsymm2.det");
    ITS->SetThicknessDet1(300.);   // detector thickness on layer 1 must be in the
range [100,300]
    ITS->SetThicknessDet2(300.);   // detector thickness on layer 2 must be in the
range [100,300]
    ITS->SetThicknessChip1(300.);  // chip thickness on layer 1 must be in the range
[150,300]
    ITS->SetThicknessChip2(300.);  // chip thickness on layer 2 must be in the range
[150,300]
    ITS->SetRails(1);              // 1 --> rails in ; 0 --> rails out
    ITS->SetCoolingFluid(1);       // 1 --> water ; 0 --> freon

The functions are the same as in the asymmetric services' geometry. For their
explanation and use see above.


3. Simulation
-------------  

     In order to run an event with a given ITS geometry put yourself in the
directory macros and do the following:

- interactive run: start aliroot and the type the command "gAlice->Run()". 
  At the end of the run exit from aliroot with the command ".q".
- batch run: type the shell command "aliroot -q -b grun.C >& fileout &" where 
  fileout is a name at your choice of the file where you want to store output 
  and error messages.

In principle there is another way to run aliroot using the script alirun but
this is not described here. Aliroot creates an output root file called
galice.root (this can be changed from within the Config.C file). If you want to
run the ITS reconstruction code, copy/move this file in the directory ITS and
read the following instructions.

4. Cluster finding (fast)
-------------------------

        Reconstructed points can be created quickly by smearing the Geant3 
hits according with the various detector resolutions and applying the 
thresholds for all detectors (fast reconstruction or, for short, "fast
points"), or slowly, in more detail, by performing a cluster finding after the
detector digitization (slow reconstruction or, for short, "slow points"). Fast
point creation is described here while slow point one is described in sections
5 and 6. From now on, we assume that you are under the directory ITS or that
the $ALICE_ROOT/ITS is in your .rootrc MacroPath. If it is the case you can do
the following, otherwise copy these macros to you local directory or prefix
$ALICE_ROOT/ITS/ to the front of the macro names.

- interactive run: start aliroot and type the command 
  ".x ITSHitsToFastPoints.C".
  At the end of the run exit from aliroot with the command ".q".
- batch run: type the shell command 
  "aliroot -q -b ITSHitsToFastPoints.C >& fileout &"
  where fileout is a name at your choice of the file where you want to store
  output and error messages.
 
    Fast points are written in the same galice.root file as you can see issuing
the shell command "ls -l galice.root" before and after their creation and
looking at the size of the root file. 
By default, fast points are created for all kind of ITS subdetectors (SPD, SDD,
and SSD). This is done with the function call

  ITS->HitsToFastRecPoints(ev,bgr_ev,size," ","All"," ");

in the macro ITSHitsToFastPoints.C. If you want to create fast points only for
one type of subdectors you have to substitute the string "All" in the above 
function call with "SPD", "SDD", or "SSD". Normal users are, however, strongly
encouraged to create the "fast points" for all subdetectors at once not
touching the macro ITSHitsToFastPoints.C. Fast points are intended only for
tests. Normal users are also strongly  encouraged to run the complete ITS
reconstruction described in the next two sections. 

  
5. Digitization
---------------

        The so called "Slow simulation" realy takes two parts. First digits are
created (Digitization) and then these digits are read back in and are
reconstructed to form RecPoints (Cluster finding). In order to run the ITS
digitization, put yourself in ITS directory, or if you have the ITS directory
in your .rootrc MacroPath, a working directory and do thefollowing:

- interactive run: start aliroot and type the command 
  ".x ITSHitsToDigits.C".
  At the end of the run exit from aliroot with the command ".q".
- batch run: type the shell command 
  "aliroot -q -b ITSHitsToDigits.C >& fileout &" 
  where fileout is a name at your choice of the file where you want to store
  output and error messages.

Digits are written in the same galice.root file as you can see issuing the
shell command "ls -l galice.root" before and after their creation and looking
at the size of the root file. By default, digits are created for all kind of
ITS subdetectors (SPD, SDD, and SSD). This is done with the function call:

  ITS->HitsToDigits(nev,nbgr_ev,size," ","All"," "); 

in the macro ITSHitsToDigits.C. If you want to create digits only for
one type of subdectors you have to substitute the string "All" in the above 
function call with "SPD", "SDD", or "SSD". Normal users are, however, strongly
encouraged to run the ITS digitization for all subdetectors at once not
touching the macro ITSHitsToDigits.C. By default the so-called "Dubna
simulation" of the pixel detectors is performed. In order to run the "Bari
simulation" of the pixel detectors (waiting for the merging of the two) you
have to use the macro ITSHitsToDigitsBari.C.


6. Cluster finding (slow)
-------------------------

In order to perform the cluster finding and create the "slow points", do the
following:

- interactive run: start aliroot and the type the command 
  ".x ITSDigitsToClusters.C".
  At the end of the run exit from aliroot with the command ".q".
- batch run: type the shell command 
  "aliroot -q -b ITSDigitsToClusters.C >& fileout &" 
  where fileout is a name at  your choice of the file where you want to store
  output and error messages.

Slow points are written in the same galice.root file as you can see issuing the
shell command "ls -l galice.root" before and after their creation and looking
at the size of the root file. By default, slow points are created for all kind
of ITS subdetectors (SPD, SDD, and SSD). This is done with the function call:

  ITS->DigitsToRecPoints(nev,last_entry,"All"); 

in the macro ITSDigitsToClusters.C. If you want to create slow points only for
one type of subdectors you have to substitute the string "All" in the above 
function call with "SPD", "SDD", or "SSD". Normal users are, however, strongly
encouraged to create the slow points for all subdetectors at once not touching
the macro ITSDigitsToClusters.C. By default the so-called "Dubna
reconstruction" of the pixel detectors is performed. In order to run the "Bari
reconstruction" of the pixel detectors (waiting for the merging of the two) you
have to use the macro ITSDigitsToClustersBari.C.


7. Useful test macros
---------------------

        Once you have created digits and slow points, you can now run some
useful test macros. They can also be used as useful starting point to
understand how to read hits, digits and points back from the galice.root
file. The macros are listed below together with some help on their use. Some of
the macros produce graphical output, so the suggestion is to run them
interactively from within aliroot by then typing a command like ".x macro.C" at
the aliroot prompt.

- new TBrower();
  This isn't a macro, so you just type it at the aliroot prompt. From here you
can open up root files and view some of what they contain. This is done by
cliking on a root file, and then cliking on the different "folders" withing
that root file. Data kept in TTrees can be histogramed symply by double cliking
on the appropreate data member. Other parts of the root file can also be
inspected in a simular way, right butting cliking for example.

- SPDclusterTest.C:
  This macro opens the galice.root file, reads the reconstructed points and
plots the SPD resolution both for layer 1 and 2, in Z and Rphi
direction. Moreover, it creates the Root file SPD_his.root which contains
some useful histograms and nt-uples which can be read back with the macro
SPD_ntuple.C. 

- SPDclusterTestBari.C:
  This macro opens the galice.root file, reads the reconstructed points and
plots several distributions relative to the Bari simulation of the SPD. 
Moreover, it creates the Root file SPD_his_bari.root which contains some useful
histograms and nt-uples. This macro should also work with both SPD simulations.

- ITSreadClustTestSPD.C:
  This macros opens the galice.root, reads SPD digits and prints them on the 
screen.

- ITSsddanalysis.C:
  This macro opens the galice.root file, performs some analysis of the 
drift detectors and creates the Root output file SDD_histos_test.root. This 
output file can then be read by the macro ITSsddtest.C which create some 
PostScript file containing reference histograms.

- SSDrecpointTest.C:
  This macro opens the galice.root file, reads the reconstructed points and 
plots the SSD resolution both for layer 5 and 6, in Z and Rphi direction. 
Moreover, it creates the Root file SSD_his.root which contains some useful 
histograms and nt-uples which can be read back with the macro SSD_ntuple.C.

- ITSreadRecPointsTest.C:
  This macro opens the galice.root file, reads the reconstructed points and 
prints them on the screen for all ITS modules. For each reconstructed point 
the following quantities are printed: the recpoint index in the module 
(0, 1, 2, ...), the X coordinate in the local reference system of the
module, the Z coordinate in the local reference system of the module, three
integers indicating the id numbers of the tracks contributing to that
reconstructed point. Only positive numbers, of course, are real tracks. 
Negative numbers (-1 for SPD, -3 for SDD, and -2 for SSD) are just there to 
fill the vector of track id's associated to a given reconstructed point.

- ITSgeoplot.C:
  This macro opens the galice.root file, reads hits, digits and recpoint for 
SPD, SDD and SSD and plots them in the global reference system.

- ITSReadPlotData.C:
  This macros opens the galice.root file and then prompts the user for an ITS 
module identified by layer, ladder and detector or by the unique ID. That 
module is then searched for hits, digits and reconstructed points and they 
are plotted in the local reference frame of the module with different symbols.


8. Occupancy
------------

        ITS occupancy can be evaluated by the macro ITSOccupancy.C which opens
the galice.root files, reads the number of digits for all subdetectors, and
calculate the occupancy as the ratio of the "fired" digits over the total
number of digits. Plots are also created showing the occupancy as a function of
the Z coordinate along the beams' axis. In order to increase the speed of the 
calculation the macro is compilable. See the comments in the code about how to 
run it.


9. Primary vertex
-----------------

        The ITS code contains a full 3D primary vertex finder. The relative
class is AliITSVertex and an example of its use is contained in the test macro
VertexMacro.C. The output of the primary vertex finder will eventually be 
incorporated in the tracking algorithms.

