<!DOCTYPE HTML PUBLIC "-// IETF/DTD HTML 2.0// EN">
<html>
<!--                                             -->
<!-- Author: ROOT team (rootdev@hpsalo.cern.ch)  -->
<!--                                             -->
<!--   Date: Thu Mar  9 00:11:48 2000            -->
<!--                                             -->
<head>
<title>AliPHOSEmcRecPoint - source file</title>
<link rev=made href="mailto:rootdev@root.cern.ch">
<meta name="rating" content="General">
<meta name="objecttype" content="Manual">
<meta name="keywords" content="software development, oo, object oriented, unix, x11, motif, windows nt, c++, html, rene brun, fons rademakers">
<meta name="description" content="ROOT - An Object Oriented Framework For Large Scale Data Analysis.">
</head>
<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#551a8b" ALINK="#ff0000" TEXT="#000000">
<a name="TopOfPage"></a>
<pre>
/**************************************************************************
 * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
 *                                                                        *
 * Author: The ALICE Off-line Project.                                    *
 * Contributors are mentioned in the code where appropriate.              *
 *                                                                        *
 * Permission to use, copy, modify and distribute this software and its   *
 * documentation strictly for non-commercial purposes is hereby granted   *
 * without fee, provided that the above copyright notice appears in all   *
 * copies and that both the copyright notice and this permission notice   *
 * appear in the supporting documentation. The authors make no claims     *
 * about the suitability of this software for any purpose. It is          *
 * provided "as is" without express or implied warranty.                  *
 **************************************************************************/

/* $Id$ */

<b>//_________________________________________________________________________</b>
<b>//  RecPoint implementation for PHOS-EMC </b>
<b>//  An EmcRecPoint is a cluster of digits   </b>
<b>//           </b>
<b>//*-- Author: Dmitri Peressounko (RRC KI &amp; SUBATECH)</b>


<b>// --- ROOT system ---</b>
#include "TPad.h"
#include "TH2.h"
#include "TMath.h" 
#include "TCanvas.h" 

<b>// --- Standard library ---</b>

#include &lt;iostream&gt;

<b>// --- AliRoot header files ---</b>

#include "<a href="../AliPHOSGeometry.h">AliPHOSGeometry.h</a>"
#include "<a href="../AliPHOSEmcRecPoint.h">AliPHOSEmcRecPoint.h</a>"
#include "AliRun.h"

ClassImp(AliPHOSEmcRecPoint)

<b>//____________________________________________________________________________</b>
<a name="AliPHOSEmcRecPoint:AliPHOSEmcRecPoint"> </a><a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:AliPHOSEmcRecPoint">AliPHOSEmcRecPoint::AliPHOSEmcRecPoint</a>(<a href="../ListOfTypes.html#Float_t">Float_t</a> W0, <a href="../ListOfTypes.html#Float_t">Float_t</a> LocMaxCut)
  : <a href=".././AliPHOSRecPoint.html">AliPHOSRecPoint</a>()
{
<b>  // ctor</b>

  fMulDigit   = 0 ;  
  fAmp   = 0. ;   
  <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fEnergyList">fEnergyList</a> = new <a href="../ListOfTypes.html#Float_t">Float_t</a>[fMaxDigit]; 
  <a href=".././AliPHOSGeometry.html">AliPHOSGeometry</a> * phosgeom =  (<a href=".././AliPHOSGeometry.html">AliPHOSGeometry</a> *) fGeom ;
  <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fDelta">fDelta</a>     =  phosgeom-&gt;GetCrystalSize(0) ; 
  <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fW0">fW0</a>        = W0 ;          
  <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fLocMaxCut">fLocMaxCut</a> = LocMaxCut ; 
  fLocPos.SetX(1000000.)  ;      //Local position should be evaluated
}

<b>//____________________________________________________________________________</b>
<a name="AliPHOSEmcRecPoint:AddDigit"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:AddDigit">AliPHOSEmcRecPoint::AddDigit</a>(AliDigitNew &amp; digit, <a href="../ListOfTypes.html#Float_t">Float_t</a> Energy)
{
<b>  // Adds a digit to the RecPoint</b>
<b>  //  and accumulates the total amplitude and the multiplicity </b>
  
  if ( fMulDigit &gt;= fMaxDigit ) { // increase the size of the lists 
    fMaxDigit*=2 ; 
    <a href="../ListOfTypes.html#int">int</a> * tempo = new ( <a href="../ListOfTypes.html#int">int</a>[fMaxDigit] ) ; 
    <a href="../ListOfTypes.html#Float_t">Float_t</a> * tempoE =  new ( <a href="../ListOfTypes.html#Float_t">Float_t</a>[fMaxDigit] ) ;

    <a href="../ListOfTypes.html#Int_t">Int_t</a> index ;     
    for ( index = 0 ; index &lt; fMulDigit ; index++ ){
      tempo[index] = fDigitsList[index] ;
      tempoE[index] = <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fEnergyList">fEnergyList</a>[index] ; 
    }
    
    delete [] fDigitsList ; 
    fDigitsList =  new ( <a href="../ListOfTypes.html#int">int</a>[fMaxDigit] ) ;
 
    delete [] <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fEnergyList">fEnergyList</a> ;
    <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fEnergyList">fEnergyList</a> =  new ( <a href="../ListOfTypes.html#Float_t">Float_t</a>[fMaxDigit] ) ;

    for ( index = 0 ; index &lt; fMulDigit ; index++ ){
      fDigitsList[index] = tempo[index] ;
      <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fEnergyList">fEnergyList</a>[index] = tempoE[index] ; 
    }
 
    delete [] tempo ;
    delete [] tempoE ; 
  } // if
  
  fDigitsList[fMulDigit]   =  (<a href="../ListOfTypes.html#int">int</a>) &amp;digit  ; 
  <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fEnergyList">fEnergyList</a>[fMulDigit++] = Energy ;
  fAmp += Energy ; 
}

<b>//____________________________________________________________________________</b>
<a name="AliPHOSEmcRecPoint:AreNeighbours"> </a><a href="../ListOfTypes.html#Bool_t">Bool_t</a> <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:AreNeighbours">AliPHOSEmcRecPoint::AreNeighbours</a>(<a href=".././AliPHOSDigit.html">AliPHOSDigit</a> * digit1, <a href=".././AliPHOSDigit.html">AliPHOSDigit</a> * digit2 ) 
{
<b>  // Tells if (true) or not (false) two digits are neighbors)</b>
  
  <a href="../ListOfTypes.html#Bool_t">Bool_t</a> aren = kFALSE ;
  
  <a href=".././AliPHOSGeometry.html">AliPHOSGeometry</a> * phosgeom =  (<a href=".././AliPHOSGeometry.html">AliPHOSGeometry</a> *) fGeom ;
  <a href="../ListOfTypes.html#Int_t">Int_t</a> relid1[4] ; 
  phosgeom-&gt;AbsToRelNumbering(digit1-&gt;GetId(), relid1) ; 

  <a href="../ListOfTypes.html#Int_t">Int_t</a> relid2[4] ; 
  phosgeom-&gt;AbsToRelNumbering(digit2-&gt;GetId(), relid2) ; 
  
  <a href="../ListOfTypes.html#Int_t">Int_t</a> rowdiff = TMath::Abs( relid1[2] - relid2[2] ) ;  
  <a href="../ListOfTypes.html#Int_t">Int_t</a> coldiff = TMath::Abs( relid1[3] - relid2[3] ) ;  

  if (( coldiff &lt;= 1 )  &amp;&amp; ( rowdiff &lt;= 1 ) &amp;&amp; (coldiff + rowdiff &gt; 0)) 
    aren = kTRUE ;
  
  return aren ;
}

<b>//____________________________________________________________________________</b>
<a name="AliPHOSEmcRecPoint:Compare"> </a><a href="../ListOfTypes.html#Int_t">Int_t</a> <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:Compare">AliPHOSEmcRecPoint::Compare</a>(TObject * obj)
{
<b>  // Compares two RecPoints according to their position in the PHOS modules</b>

  <a href="../ListOfTypes.html#Int_t">Int_t</a> rv ; 

  <a href=".././AliPHOSEmcRecPoint.html">AliPHOSEmcRecPoint</a> * clu = (<a href=".././AliPHOSEmcRecPoint.html">AliPHOSEmcRecPoint</a> *)obj ; 

 
  <a href="../ListOfTypes.html#Int_t">Int_t</a> phosmod1 = this-&gt;GetPHOSMod() ;
  <a href="../ListOfTypes.html#Int_t">Int_t</a> phosmod2 = clu-&gt;GetPHOSMod() ;

  TVector3 locpos1; 
  this-&gt;<a href="#AliPHOSEmcRecPoint:GetLocalPosition">GetLocalPosition</a>(locpos1) ;
  TVector3 locpos2;  
  clu-&gt;<a href="#AliPHOSEmcRecPoint:GetLocalPosition">GetLocalPosition</a>(locpos2) ;  

  if(phosmod1 == phosmod2 ) {
    <a href="../ListOfTypes.html#Int_t">Int_t</a> rowdif = (<a href="../ListOfTypes.html#Int_t">Int_t</a>)TMath::Ceil(locpos1.X()/<a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fDelta">fDelta</a>)-(<a href="../ListOfTypes.html#Int_t">Int_t</a>)TMath::Ceil(locpos2.X()/<a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fDelta">fDelta</a>) ;
    if (rowdif&gt; 0) 
      rv = -1 ;
     else if(rowdif &lt; 0) 
       rv = 1 ;
    else if(locpos1.Z()&gt;locpos2.Z()) 
      rv = -1 ;
    else 
      rv = 1 ; 
     }

  else {
    if(phosmod1 &lt; phosmod2 ) 
      rv = -1 ;
    else 
      rv = 1 ;
  }

  return rv ; 
}

<b>//______________________________________________________________________________</b>
<a name="AliPHOSEmcRecPoint:ExecuteEvent"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:ExecuteEvent">AliPHOSEmcRecPoint::ExecuteEvent</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> event, <a href="../ListOfTypes.html#Int_t">Int_t</a> px, <a href="../ListOfTypes.html#Int_t">Int_t</a> py)
{
<b>  // Execute action corresponding to one event</b>
<b>  //  This member function is called when a <a href=".././AliPHOSRecPoint.html">AliPHOSRecPoint</a> is clicked with the locator</b>
<b>  //</b>
<b>  //  If Left button is clicked on <a href=".././AliPHOSRecPoint.html">AliPHOSRecPoint</a>, the digits are switched on    </b>
<b>  //  and switched off when the mouse button is released.</b>
<b>  //</b>

<b>  //   static <a href="../ListOfTypes.html#Int_t">Int_t</a> pxold, pyold;</b>

   static TGraph *  digitgraph = 0 ;

   if (!gPad-&gt;IsEditable()) return;

   TH2F * histo = 0 ;
   TCanvas * histocanvas ; 
   
   switch (event) {
   
   case kButton1Down: {
     <a href=".././AliPHOSDigit.html">AliPHOSDigit</a> * digit ;
     <a href=".././AliPHOSGeometry.html">AliPHOSGeometry</a> * phosgeom =  (<a href=".././AliPHOSGeometry.html">AliPHOSGeometry</a> *) fGeom ;
     <a href="../ListOfTypes.html#Int_t">Int_t</a> iDigit;
     <a href="../ListOfTypes.html#Int_t">Int_t</a> relid[4] ;
     <a href="../ListOfTypes.html#Float_t">Float_t</a> xi[fMulDigit] ;
     <a href="../ListOfTypes.html#Float_t">Float_t</a> zi[fMulDigit] ;

<b>     // create the histogram for the single cluster </b>
<b>     // 1. gets histogram boundaries</b>
     <a href="../ListOfTypes.html#Float_t">Float_t</a> ximax = -999. ; 
     <a href="../ListOfTypes.html#Float_t">Float_t</a> zimax = -999. ; 
     <a href="../ListOfTypes.html#Float_t">Float_t</a> ximin = 999. ; 
     <a href="../ListOfTypes.html#Float_t">Float_t</a> zimin = 999. ;
 
     for(iDigit=0; iDigit&lt;fMulDigit; iDigit++) {
       digit = (<a href=".././AliPHOSDigit.html">AliPHOSDigit</a> *) fDigitsList[iDigit];
       phosgeom-&gt;AbsToRelNumbering(digit-&gt;GetId(), relid) ;
       phosgeom-&gt;RelPosInModule(relid, xi[iDigit], zi[iDigit]);
       if ( xi[iDigit] &gt; ximax )
	 ximax = xi[iDigit] ; 
       if ( xi[iDigit] &lt; ximin )
	 ximin = xi[iDigit] ; 
       if ( zi[iDigit] &gt; zimax )
	 zimax = zi[iDigit] ; 
       if ( zi[iDigit] &lt; zimin )
	 zimin = zi[iDigit] ;     
     }
     ximax += phosgeom-&gt;GetCrystalSize(0) / 2. ;
     zimax += phosgeom-&gt;GetCrystalSize(2) / 2. ;
     ximin -= phosgeom-&gt;GetCrystalSize(0) / 2. ;
     zimin -= phosgeom-&gt;GetCrystalSize(2) / 2. ;
     <a href="../ListOfTypes.html#Int_t">Int_t</a> xdim = (<a href="../ListOfTypes.html#int">int</a>)( (ximax - ximin ) / phosgeom-&gt;GetCrystalSize(0) + 0.5  ) ; 
     <a href="../ListOfTypes.html#Int_t">Int_t</a> zdim = (<a href="../ListOfTypes.html#int">int</a>)( (zimax - zimin ) / phosgeom-&gt;GetCrystalSize(2) + 0.5 ) ;
 
<b>     // 2. gets the histogram title</b>

     <a href="../ListOfTypes.html#Text_t">Text_t</a> title[100] ; 
     sprintf(title,"Energy=%1.2f GeV ; Digits ; %d ", GetEnergy(), GetDigitsMultiplicity()) ;
  
     if (!histo) {
       delete histo ; 
       histo = 0 ; 
     }
     histo = new TH2F("cluster3D", title,  xdim, ximin, ximax, zdim, zimin, zimax)  ;

     <a href="../ListOfTypes.html#Float_t">Float_t</a> x, z ; 
     for(iDigit=0; iDigit&lt;fMulDigit; iDigit++) {
       digit = (<a href=".././AliPHOSDigit.html">AliPHOSDigit</a> *) fDigitsList[iDigit];
       phosgeom-&gt;AbsToRelNumbering(digit-&gt;GetId(), relid) ;
       phosgeom-&gt;RelPosInModule(relid, x, z);
       histo-&gt;Fill(x, z, <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fEnergyList">fEnergyList</a>[iDigit] ) ;
     }

     if (!digitgraph) {
       digitgraph = new TGraph(fMulDigit,xi,zi);
       digitgraph-&gt; SetMarkerStyle(5) ; 
       digitgraph-&gt; SetMarkerSize(1.) ;
       digitgraph-&gt; SetMarkerColor(1) ;
       digitgraph-&gt; Paint("P") ;
     }

     <a href="#AliPHOSEmcRecPoint:Print">Print</a>() ;
     histocanvas = new TCanvas("cluser", "a single cluster", 600, 500) ; 
     histocanvas-&gt;Draw() ; 
     histo-&gt;Draw("lego1") ; 

     break;
   }

   case kButton1Up: 
     if (digitgraph) {
       delete digitgraph  ;
       digitgraph = 0 ;
     }
     break;
  
   }
}

<b>//____________________________________________________________________________</b>
<a name="AliPHOSEmcRecPoint:GetDispersion"> </a><a href="../ListOfTypes.html#Float_t">Float_t</a>  <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:GetDispersion">AliPHOSEmcRecPoint::GetDispersion</a>() 
{
<b>  // Calculates the dispersion of the shower at the origine of the RecPoint</b>

  <a href="../ListOfTypes.html#Float_t">Float_t</a> d    = 0 ;
  <a href="../ListOfTypes.html#Float_t">Float_t</a> wtot = 0 ;

  TVector3 locpos;
  <a href="#AliPHOSEmcRecPoint:GetLocalPosition">GetLocalPosition</a>(locpos);
  <a href="../ListOfTypes.html#Float_t">Float_t</a> x = locpos.X() ;
  <a href="../ListOfTypes.html#Float_t">Float_t</a> z = locpos.Z() ;

  <a href=".././AliPHOSDigit.html">AliPHOSDigit</a> * digit ;
  <a href=".././AliPHOSGeometry.html">AliPHOSGeometry</a> * phosgeom =  (<a href=".././AliPHOSGeometry.html">AliPHOSGeometry</a> *) fGeom ;
  
  <a href="../ListOfTypes.html#Int_t">Int_t</a> iDigit;
  for(iDigit=0; iDigit&lt;fMulDigit; iDigit++) {
    digit = (<a href=".././AliPHOSDigit.html">AliPHOSDigit</a> *) fDigitsList[iDigit];
    <a href="../ListOfTypes.html#Int_t">Int_t</a> relid[4] ;
    <a href="../ListOfTypes.html#Float_t">Float_t</a> xi ;
    <a href="../ListOfTypes.html#Float_t">Float_t</a> zi ;
    phosgeom-&gt;AbsToRelNumbering(digit-&gt;GetId(), relid) ;
    phosgeom-&gt;RelPosInModule(relid, xi, zi);
    <a href="../ListOfTypes.html#Float_t">Float_t</a> w = TMath::Max(0.,<a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fW0">fW0</a>+TMath::Log(<a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fEnergyList">fEnergyList</a>[iDigit]/fAmp ) ) ;
    d += w*((xi-x)*(xi-x) + (zi-z)*(zi-z) ) ; 
    wtot+=w ;
  }

  d /= wtot ;

  return TMath::Sqrt(d) ;
}

<b>//____________________________________________________________________________</b>
<a name="AliPHOSEmcRecPoint:GetElipsAxis"> </a><a href="../ListOfTypes.html#void">void</a>  <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:GetElipsAxis">AliPHOSEmcRecPoint::GetElipsAxis</a>(<a href="../ListOfTypes.html#Float_t">Float_t</a> * lambda)
{
<b>  // Calculates the axis of the shower ellipsoid</b>
  
  <a href="../ListOfTypes.html#Float_t">Float_t</a> wtot = 0. ;
  <a href="../ListOfTypes.html#Float_t">Float_t</a> x    = 0.;
  <a href="../ListOfTypes.html#Float_t">Float_t</a> z    = 0.;
  <a href="../ListOfTypes.html#Float_t">Float_t</a> dxx  = 0.;
  <a href="../ListOfTypes.html#Float_t">Float_t</a> dzz  = 0.;
  <a href="../ListOfTypes.html#Float_t">Float_t</a> dxz  = 0.;

  <a href=".././AliPHOSDigit.html">AliPHOSDigit</a> * digit ;
  <a href=".././AliPHOSGeometry.html">AliPHOSGeometry</a> * phosgeom =  (<a href=".././AliPHOSGeometry.html">AliPHOSGeometry</a> *) fGeom ;
  <a href="../ListOfTypes.html#Int_t">Int_t</a> iDigit;

  for(iDigit=0; iDigit&lt;fMulDigit; iDigit++) {
    digit = (<a href=".././AliPHOSDigit.html">AliPHOSDigit</a> *) fDigitsList[iDigit];
    <a href="../ListOfTypes.html#Int_t">Int_t</a> relid[4] ;
    <a href="../ListOfTypes.html#Float_t">Float_t</a> xi ;
    <a href="../ListOfTypes.html#Float_t">Float_t</a> zi ;
    phosgeom-&gt;AbsToRelNumbering(digit-&gt;GetId(), relid) ;
    phosgeom-&gt;RelPosInModule(relid, xi, zi);
    <a href="../ListOfTypes.html#Float_t">Float_t</a> w = TMath::Max(0.,<a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fW0">fW0</a>+TMath::Log(<a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fEnergyList">fEnergyList</a>[iDigit]/fAmp ) ) ;
    dxx  += w * xi * xi ;
    x    += w * xi ;
    dzz  += w * zi * zi ;
    z    += w * zi ; 
    dxz  += w * xi * zi ; 
    wtot += w ;
  }

  dxx /= wtot ;
  x   /= wtot ;
  dxx -= x * x ;
  dzz /= wtot ;
  z   /= wtot ;
  dzz -= z * z ;
  dxz /= wtot ;
  dxz -= x * z ;

  lambda[0] = TMath::Sqrt( 0.5 * (dxx + dzz) + TMath::Sqrt( 0.25 * (dxx - dzz) * (dxx - dzz) + dxz * dxz ) ) ;
  lambda[1] = TMath::Sqrt( 0.5 * (dxx + dzz) - TMath::Sqrt( 0.25 * (dxx - dzz) * (dxx - dzz) + dxz * dxz ) ) ;
}

<b>//____________________________________________________________________________</b>
<a name="AliPHOSEmcRecPoint:GetLocalPosition"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:GetLocalPosition">AliPHOSEmcRecPoint::GetLocalPosition</a>(TVector3 &amp;LPos)
{
<b>  // Calculates the center of gravity in the local PHOS-module coordinates </b>
  
  if( fLocPos.X() &lt; 1000000.) { // already evaluated
   LPos = fLocPos ;
   return ;
  }

  <a href="../ListOfTypes.html#Float_t">Float_t</a> wtot = 0. ;
 
  <a href="../ListOfTypes.html#Int_t">Int_t</a> relid[4] ;

  <a href="../ListOfTypes.html#Float_t">Float_t</a> x = 0. ;
  <a href="../ListOfTypes.html#Float_t">Float_t</a> z = 0. ;
  
  <a href=".././AliPHOSDigit.html">AliPHOSDigit</a> * digit ;

  <a href=".././AliPHOSGeometry.html">AliPHOSGeometry</a> * phosgeom =  (<a href=".././AliPHOSGeometry.html">AliPHOSGeometry</a> *) fGeom ;

  <a href="../ListOfTypes.html#Int_t">Int_t</a> iDigit;


  for(iDigit=0; iDigit&lt;fMulDigit; iDigit++) {
    digit = (<a href=".././AliPHOSDigit.html">AliPHOSDigit</a> *) fDigitsList[iDigit];

    <a href="../ListOfTypes.html#Float_t">Float_t</a> xi ;
    <a href="../ListOfTypes.html#Float_t">Float_t</a> zi ;
    phosgeom-&gt;AbsToRelNumbering(digit-&gt;GetId(), relid) ;
    phosgeom-&gt;RelPosInModule(relid, xi, zi);
    <a href="../ListOfTypes.html#Float_t">Float_t</a> w = TMath::Max( 0., <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fW0">fW0</a> + TMath::Log( <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fEnergyList">fEnergyList</a>[iDigit] / fAmp ) ) ;
    x    += xi * w ;
    z    += zi * w ;
    wtot += w ;

  }

  x /= wtot ;
  z /= wtot ;
  fLocPos.SetX(x)  ;
  fLocPos.SetY(0.) ;
  fLocPos.SetZ(z)  ;

  LPos = fLocPos ;
}

<b>//____________________________________________________________________________</b>
<a name="AliPHOSEmcRecPoint:GetMaximalEnergy"> </a><a href="../ListOfTypes.html#Float_t">Float_t</a> <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:GetMaximalEnergy">AliPHOSEmcRecPoint::GetMaximalEnergy</a>(<a href="../ListOfTypes.html#void">void</a>)
{
<b>  // Finds the maximum energy in the cluster</b>
  
  <a href="../ListOfTypes.html#Float_t">Float_t</a> menergy = 0. ;

  <a href="../ListOfTypes.html#Int_t">Int_t</a> iDigit;

  for(iDigit=0; iDigit&lt;fMulDigit; iDigit++) {
 
    if(<a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fEnergyList">fEnergyList</a>[iDigit] &gt; menergy) 
      menergy = <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fEnergyList">fEnergyList</a>[iDigit] ;
  }
  return menergy ;
}

<b>//____________________________________________________________________________</b>
<a name="AliPHOSEmcRecPoint:GetMultiplicityAtLevel"> </a><a href="../ListOfTypes.html#Int_t">Int_t</a> <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:GetMultiplicityAtLevel">AliPHOSEmcRecPoint::GetMultiplicityAtLevel</a>(<a href="../ListOfTypes.html#Float_t">Float_t</a> H) 
{
<b>  // Calculates the multiplicity of digits with energy larger than H*energy </b>
  
  <a href="../ListOfTypes.html#Int_t">Int_t</a> multipl   = 0 ;
  <a href="../ListOfTypes.html#Int_t">Int_t</a> iDigit ;
  for(iDigit=0; iDigit&lt;fMulDigit; iDigit++) {

    if(<a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fEnergyList">fEnergyList</a>[iDigit] &gt; H * fAmp) 
      multipl++ ;
  }
  return multipl ;
}

<b>//____________________________________________________________________________</b>
<a name="AliPHOSEmcRecPoint:GetNumberOfLocalMax"> </a><a href="../ListOfTypes.html#Int_t">Int_t</a>  <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:GetNumberOfLocalMax">AliPHOSEmcRecPoint::GetNumberOfLocalMax</a>(<a href="../ListOfTypes.html#Int_t">Int_t</a> *  maxAt, <a href="../ListOfTypes.html#Float_t">Float_t</a> * maxAtEnergy) 
{ 
<b>  // Calculates the number of local maxima in the cluster using fLocalMaxCut as the minimum</b>
<b>  //  energy difference between two local maxima</b>

  <a href=".././AliPHOSDigit.html">AliPHOSDigit</a> * digit ;
  <a href=".././AliPHOSDigit.html">AliPHOSDigit</a> * digitN ;
  

  <a href="../ListOfTypes.html#Int_t">Int_t</a> iDigitN ;
  <a href="../ListOfTypes.html#Int_t">Int_t</a> iDigit ;

  for(iDigit = 0; iDigit &lt; fMulDigit; iDigit++){
    maxAt[iDigit] = fDigitsList[iDigit] ;
  }
  
  for(iDigit = 0 ; iDigit &lt; fMulDigit; iDigit++) {   
    if(maxAt[iDigit] != -1) {
      digit = (<a href=".././AliPHOSDigit.html">AliPHOSDigit</a> *) maxAt[iDigit] ;
         
      for(iDigitN = 0; iDigitN &lt; fMulDigit; iDigitN++) {	
	digitN = (<a href=".././AliPHOSDigit.html">AliPHOSDigit</a> *) fDigitsList[iDigitN] ; 
	
	if ( <a href="#AliPHOSEmcRecPoint:AreNeighbours">AreNeighbours</a>(digit, digitN) ) {
	  if (<a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fEnergyList">fEnergyList</a>[iDigit] &gt; <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fEnergyList">fEnergyList</a>[iDigitN] ) {    
	    maxAt[iDigitN] = -1 ;
<b>	    // but may be digit too is not local max ?</b>
	    if(<a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fEnergyList">fEnergyList</a>[iDigit] &lt; <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fEnergyList">fEnergyList</a>[iDigitN] + <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fLocMaxCut">fLocMaxCut</a>) 
	      maxAt[iDigit] = -1 ;
	  }
	  else {
	    maxAt[iDigit] = -1 ;
<b>	    // but may be digitN too is not local max ?</b>
	    if(<a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fEnergyList">fEnergyList</a>[iDigit] &gt; <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fEnergyList">fEnergyList</a>[iDigitN] - <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fLocMaxCut">fLocMaxCut</a>) 
	      maxAt[iDigitN] = -1 ; 
	  } 
	} // if Areneighbours
      } // while digitN
    } // slot not empty
  } // while digit
  
  iDigitN = 0 ;
  for(iDigit = 0; iDigit &lt; fMulDigit; iDigit++) { 
    if(maxAt[iDigit] != -1){
      maxAt[iDigitN] = maxAt[iDigit] ;
      maxAtEnergy[iDigitN] = <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fEnergyList">fEnergyList</a>[iDigit] ;
      iDigitN++ ; 
    }
  }
  return iDigitN ;
}


<b>// //____________________________________________________________________________</b>
<b>// <a href=".././AliPHOSEmcRecPoint.html">AliPHOSEmcRecPoint</a>&amp; <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:operator">AliPHOSEmcRecPoint::operator</a> = (<a href=".././AliPHOSEmcRecPoint.html">AliPHOSEmcRecPoint</a> Clu) </b>
<b>// {</b>
<b>//   <a href="../ListOfTypes.html#int">int</a> * dl = Clu.GetDigitsList() ; </b>
 
<b>//  if(fDigitsList) </b>
<b>//     delete fDigitsList  ;</b>

<b>//   <a href=".././AliPHOSDigit.html">AliPHOSDigit</a> * digit ;</b>
 
<b>//   <a href="../ListOfTypes.html#Int_t">Int_t</a> iDigit;</b>

<b>//   for(iDigit=0; iDigit&lt;fMulDigit; iDigit++) {</b>
<b>//     digit = (<a href=".././AliPHOSDigit.html">AliPHOSDigit</a> *) dl[iDigit];</b>
<b>//     <a href="#AliPHOSEmcRecPoint:AddDigit">AddDigit</a>(*digit) ;</b>
<b>//   }</b>

<b>//   fAmp       = Clu.<a href="#AliPHOSEmcRecPoint:GetTotalEnergy">GetTotalEnergy</a>() ;</b>
<b>//   fGeom      = Clu.GetGeom() ;</b>
<b>//   TVector3 locpos;</b>
<b>//   Clu.<a href="#AliPHOSEmcRecPoint:GetLocalPosition">GetLocalPosition</a>(locpos) ;</b>
<b>//   fLocPos    = locpos;</b>
<b>//   fMulDigit       = Clu.<a href="#AliPHOSEmcRecPoint:GetMultiplicity">GetMultiplicity</a>() ;</b>
<b>//   fMaxDigit  = Clu.<a href="#AliPHOSEmcRecPoint:GetMaximumMultiplicity">GetMaximumMultiplicity</a>() ;</b>
<b>//   <a href=".././AliPHOSRecPoint.html#AliPHOSRecPoint:fPHOSMod">fPHOSMod</a>   = Clu.GetPHOSMod() ;</b>
<b>//   <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fW0">fW0</a>        = Clu.<a href="#AliPHOSEmcRecPoint:GetLogWeightCut">GetLogWeightCut</a>() ; </b>
<b>//   <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fDelta">fDelta</a>     = Clu.<a href="#AliPHOSEmcRecPoint:GetDelta">GetDelta</a>() ;</b>
<b>//   <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fLocMaxCut">fLocMaxCut</a> = Clu.<a href="#AliPHOSEmcRecPoint:GetLocMaxCut">GetLocMaxCut</a>() ;</b>
  
<b>//   delete dl ; </b>
 
<b>//   return *this ;</b>
<b>// }</b>

<b>//____________________________________________________________________________</b>
<a name="AliPHOSEmcRecPoint:Print"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:Print">AliPHOSEmcRecPoint::Print</a>(<a href="../ListOfTypes.html#Option_t">Option_t</a> * option) 
{
<b>  // Print the list of digits belonging to the cluster</b>
  
  cout &lt;&lt; "<a href=".././AliPHOSEmcRecPoint.html">AliPHOSEmcRecPoint</a>: " &lt;&lt; endl ;

  <a href=".././AliPHOSDigit.html">AliPHOSDigit</a> * digit ; 
  <a href="../ListOfTypes.html#Int_t">Int_t</a> iDigit;
  <a href=".././AliPHOSGeometry.html">AliPHOSGeometry</a> * phosgeom =  (<a href=".././AliPHOSGeometry.html">AliPHOSGeometry</a> *) fGeom ;

  <a href="../ListOfTypes.html#Float_t">Float_t</a> xi ;
  <a href="../ListOfTypes.html#Float_t">Float_t</a> zi ;
  <a href="../ListOfTypes.html#Int_t">Int_t</a> relid[4] ; 
 
  for(iDigit=0; iDigit&lt;fMulDigit; iDigit++) {
    digit = (<a href=".././AliPHOSDigit.html">AliPHOSDigit</a> *) fDigitsList[iDigit];
    phosgeom-&gt;AbsToRelNumbering(digit-&gt;GetId(), relid) ;
    phosgeom-&gt;RelPosInModule(relid, xi, zi);
    cout &lt;&lt; " Id = " &lt;&lt; digit-&gt;GetId() ;  
    cout &lt;&lt; "   module  = " &lt;&lt; relid[0] ;  
    cout &lt;&lt; "   x  = " &lt;&lt; xi ;  
    cout &lt;&lt; "   z  = " &lt;&lt; zi ;  
    cout &lt;&lt; "   Energy = " &lt;&lt; <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fEnergyList">fEnergyList</a>[iDigit] &lt;&lt; endl ;
  }
  cout &lt;&lt; "       Multiplicity    = " &lt;&lt; fMulDigit  &lt;&lt; endl ;
  cout &lt;&lt; "       Cluster Energy  = " &lt;&lt; fAmp &lt;&lt; endl ;
  
}

<b>//______________________________________________________________________________</b>
<a name="AliPHOSEmcRecPoint:Streamer"> </a><a href="../ListOfTypes.html#void">void</a> <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:Streamer">AliPHOSEmcRecPoint::Streamer</a>(TBuffer &amp;R__b)
{
<b>  // Stream an object of class <a href=".././AliPHOSEmcRecPoint.html">AliPHOSEmcRecPoint</a>.</b>
<b>  // Needed because of the array <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fEnergyList">fEnergyList</a></b>
  
   if (R__b.IsReading()) {
      <a href="../ListOfTypes.html#Version_t">Version_t</a> R__v = R__b.ReadVersion(); if (R__v) { }
      <a href=".././AliPHOSRecPoint.html#AliPHOSRecPoint:Streamer">AliPHOSRecPoint::Streamer</a>(R__b);
      R__b &gt;&gt; <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fDelta">fDelta</a>;
      R__b &gt;&gt; <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fLocMaxCut">fLocMaxCut</a>;
      R__b.ReadArray(<a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fEnergyList">fEnergyList</a>);
      R__b &gt;&gt; <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fW0">fW0</a>;
   } else {
      R__b.WriteVersion(<a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:IsA">AliPHOSEmcRecPoint::IsA</a>());
      <a href=".././AliPHOSRecPoint.html#AliPHOSRecPoint:Streamer">AliPHOSRecPoint::Streamer</a>(R__b);
      R__b &lt;&lt; <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fDelta">fDelta</a>;
      R__b &lt;&lt; <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fLocMaxCut">fLocMaxCut</a>;
      R__b.WriteArray(<a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fEnergyList">fEnergyList</a>, GetMaximumDigitMultiplicity() );
      R__b &lt;&lt; <a href=".././AliPHOSEmcRecPoint.html#AliPHOSEmcRecPoint:fW0">fW0</a>;
   }
}


</pre>

<!--SIGNATURE-->
<br>
<address>
<hr>
<center>
<a href="http://root.cern.ch/root/Welcome.html">ROOT page</a> - <a href="../ClassIndex.html">Class index</a> - <a href="#TopOfPage">Top of the page</a><br>
</center>
<hr>This page has been automatically generated. If you have any comments or suggestions about the page layout send a mail to <a href="mailto:rootdev@root.cern.ch">ROOT support</a>, or contact <a href="mailto:rootdev@root.cern.ch">the developers</a> with any questions or problems regarding ROOT.
</address>
</body>
</html>
