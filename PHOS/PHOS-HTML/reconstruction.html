<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
               "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.51 [en] (X11; I; Linux 2.2.5-15 i686) [Netscape]">
   <title>PHOS Reconstruction in AliRoot</title>
    <link REL="stylesheet" href="http://www-subatech.in2p3.fr/~photons/gps_alice.css" type="text/css">
</head>
<body>
    <h1>
      PHOS Reconstruction
    </h1>
    <hr><hr>
    <ul>
      <li>
	<a href="reconstruction.html#Definitions and objectives">Definitions and objectives</a>
	<ul>
	  <li>
	    <a href="reconstruction.html#What is PHOS">What is PHOS ?</a>
	  </li>
	  <li>
	    <a href="reconstruction.html#Reconstruction design">Reconstruction design</a>
	  </li>
	  <li>
	    <a href="reconstruction.html#How to use it">How to use it</a> 
	  </li>
	</ul>
      <li>
	<a href="reconstruction.html#Clusterization">Clusterization</a>
      </li>
      <li>
	<a href="reconstruction.html#Sub-Track construction">Sub-Track construction</a>
      </li>
      <li>
	<a href="reconstruction.html#Particle identification">Particle identification</a>
      </li>
      <li>
	<a href="reconstruction.html#Disk Storage Structure">Disk Storage Structure</a>
      </li>
      <li>
	<a href="reconstruction.html#How are the links implemented">How are the links implemented</a>
      </li>
    </ul>
    <a NAME="Definitions and objectives"></a>
    <hr><hr> 
   <h1>
      Definitions and objectives
    </h1>
    <a NAME="What is PHOS"></a>   <h2>
      What is PHOS ?
    </h2>
    PHOS is the association of two sub-detectors: 
    <ul>
      <li>
	the lead-tungstate crystals electromagnetic-calorimeter named <b>EMCA</b>, 
      </li>
      <li>
	and a pre-shower gas detector named <b>PPSD</b>. 
	</li>
    </ul>
    Both sub-detectors are physically organized in <i>modules</i>. A separate document
    is dedicated to the description of the <a href="simulation.html">PHOS geometry</a>.
    <a NAME="Reconstruction design"></a>   
    <h2>
      Reconstruction design
    </h2>
    The reconstruction software consists in making <a href="html/AliPHOSRecParticle.html">particles</a> 
    from the <a href="html/AliPHOSDigit.html">digits</a> generated by the <a href="simulation.html">simulation</a>. 
   <p>
    <center>
      <a href="images/phosreconstructs.eps"> 
	<img src="images/phosreconstructs.gif" alt="Use Case of reconstruction" width=800>
      </a>
      <p>
	<b> Figure 1.: </b> <i>Use Case for reconstruction. Only PHOS is implemented. Other detectors are ignored. 
	  Click on image for full scale</i>
    </center>
    The PHOS reconstruction is delegated by the <a href="html/AliPHOSv0.html">detector</a> to a 
    <a href="html/AliPHOSReconstructioner.html">reconstructioner</a> algorithmic object. It proceeds along three steps: 
    <dl>
      <dt>
	<b>Clusterization</b>
      </dt>
      <dd>
	The reconstruction of the showers (total energy loss and incident direction) 
	induced in the EM calorimeter (<a href="html/AliPHOSEmcRecPoint.html">AliPHOSEmcRecPoint</a>)
	and of the pads hit in the pre-shower detector (<a href="html/AliPHOSPpsdRecPoint.html" >AliPHOSPpsdRecPoint</a>).
	The clustering is delegated to the algorithmic object <a href="html/AliPHOSClusterizerv1.html">AliPHOSClusterizerv1</a> 
	which derives from the interface <a href="html/AliPHOSClusterizer.html">AliPHOSClusterizer</a>. The clusterization is controlled
	by several parameters.
      </dd>
      <dt>
	<b>Sub-Track construction</b>
      </dt>
      <dd>
	Sub tracks are obtained by combining reconstructed points in EMCA and PPSD to form a track segment 
	(<a href="html/AliPHOSTrackSegment.html">AliPHOSTrackSegment</a>). This construction is delegated to the 
	algorithmic object <a href="html/AliPHOSTrackSegmentMakerv1.html">AliPHOSTrackSegmentMakerv1</a> 
	which derives from the interface <a href="html/AliPHOSTrackSegmentMaker.html">AliPHOSTrackSegmentMaker</a>. 
      </dd>
      <dt>
	<b>Particle identification</b>
      </dt>
      <dd>
	From each track segment a reconstructed particle (<a href="html/AliPHOSRecParticle.html">AliPHOSRecParticle</a>)
	is made the identification being based on the information delivered by the PPSD (which PPSD stage is hit) 
	and by EMCA (shower profile and topology).The identification is delegated to the 
	algorithmic object <a href="html/AliPHOSPIDv1.html">AliPHOSPIDv1</a> 
	which derives from the interface <a href="html/AliPHOSPID.html">AliPHOSPID</a>. Several parameters control the identification
	procedure.
      </dd>
    </dl>
    The first step is detector specific, i.e. does not require any information
    about other detectors. The two last steps may (and probably will) depend on
    other detector reconstructions (connecting sub tracks or combining particle identification delivered by 
    various sub-detectors).
	<a NAME="How to use it"></a> 
    <h2>
      How to use it ?
    </h2>
    This is a little piece of code which shows how to use the reconstruction. It can be used in a Root macro or the class
    <a href="html/AliPHOSAnalyze.html">AliPHOSAnalyze</a> can be used instead together with the GUI interface 
    <a href="EditorBar.C">EditorBar.C</a>:
    <pre class="code">
      fRootFile   = new TFile("MyFileName", "update") ;   // open the root file created by the simulation
      gAlice = (AliRun*) fRootFile->Get("gAlice");        // get from file the AliRun object
      fPHOS  = (AliPHOSv0 *)gAlice->GetDetector("PHOS") ; // get from file the detector object
      fGeom  = AliPHOSGeometry::GetInstance(              // get the geometry used for the simulation
                     fPHOS->GetGeometry()->GetName(), 
                     fPHOS->GetGeometry()->GetTitle() ) ;

      //========== Initializes the Index to Object converter
      fObjGetter = AliPHOSIndexToObject::GetInstance(fPHOS) ; 
  
      //========== Create the Clusterizer and set a few parameters
      fClu =  new AliPHOSClusterizerv1() ; 
      fClu->SetEmcEnergyThreshold(0.030) ; 
      fClu->SetEmcClusteringThreshold(1.0) ; 
      fClu->SetPpsdEnergyThreshold    (0.0000002) ; 
      fClu->SetPpsdClusteringThreshold(0.0000001) ; 
      fClu->SetLocalMaxCut(0.03) ;
      fClu->SetCalibrationParameters(0., 0.00000001) ;  
      cout <<  "AnalyzeOneEvent > using clusterizer " << fClu->GetName() << endl ; 
      fClu->PrintParameters() ; 
    
      //========== Creates the track segment maker
      fTrs = new AliPHOSTrackSegmentMakerv1() ;
      cout <<  "AnalyzeOneEvent > using tack segment maker " << fTrs->GetName() << endl ; 
      fTrs->UnsetUnfoldFlag() ;
    
      //========== Creates the particle identifier
      fPID = new AliPHOSPIDv1() ;
      cout <<  "AnalyzeOneEvent > using particle identifier " << fPID->GetName() << endl ; 
      fPID->SetShowerProfileCuts(0., 0., 0., 0.) ;
      fPIS->SetDispersionCutOff(0.34) ;

      //========== Creates the Reconstructioner  
      fRec = new AliPHOSReconstructioner(fClu, fTrs, fPID) ;     
    
      //=========== Connect the various Tree's for evt
      gAlice->GetEvent(evt);
    
      //=========== Fill the fDigits array from the Digit TTree
      gAlice->TreeD()->GetEvent(0) ;     
      
      //=========== Do the reconstruction
      fPHOS->Reconstruction(fRec);  
    
      // =========== Write to the root file
      fRootFile->Close() ; 
    </pre>
    <hr>
    <a NAME="Clusterization"></a> 
   <h1>
      <a href="html/AliPHOSClusterizerv1.html">Clusterization</a>
    </h1>
    A <a href="html/AliPHOSDigit.html">digit</a> is a set of two numbers: the id of the elementary cell
    numbered from 1 to the maximum number of cells (EMCA+PPSD), and a digitized deposited energy. With 
    the help of the <a href="html/AliPHOSGeometry.html">geometry</a> object the absolute id is converted into
    a relative numbering with a single EMCA or PPSD module, in terms of rows and columns 
    ( <i>ALIPHOSGeometry::AbsToRelNumbering()</i> ). A clustering algorithm ( <i> AliPHOSClusterizerv1::MakeClusters()</i> )
    groups neighbouring cells in EMCA and PPSD ( <i>AliPHOSClusterizerv1::AreNeighbours()</i> ) where two cells
    are defined as neighbours if they have a common edge or a common corner. The algorithm is controlled with
    alltogether 4 parameters:
    <ul>
      <li> the energy thresholds (one for EMCA, <i>fEmcEnergyThreshold</i> and one for PPSD, <i> fPpsdEnergyThreshold</i>) 
	which the deposited energy of the digits must surpass to be taken into account for the clusterization;
      </li>
      <li> the energy thresholds (one for EMCA, <i>fEmcEnergyThreshold</i> and one for PPSD, <i>fPpsdEnergyThreshold</i>) 
	which the deposited energy of the digits must surpass to start a cluster.
      </li>
    </ul>
    An ensemble of neighbouring digits is called a reconstructed point. The PHOS clusterizer produces 
    <a href="html/AliPHOSEmcRecPoint.html">EmcRecPoints</a> and  <a href="html/AliPHOSPpsdRecPoint.html">PpsdRecPoints</a>
    deriving form the base class <a href="html/AliPHOSRecPoint.html">AliPHOSRecPoint</a>. Each reconstructed point
    points, through a mechanism described later, to the digits at its origin. Since a digit remembers which
    primary particle(s) were at its origin, the list of primary particles at the origin of a reconstructed
    point is provided by the method <i>AliPHOSRecPoint::GetPrimaries()</i>).
    <p>
      The reconstructed points are contained in two <a href="http://root.cern.ch/root/html/TObjArray.html">TObjArray</a> 
      (mandatory because the size of a reconstructed
      point depends on the number of digits used to build it) which are stored in <i>TreeR</i>, branch <i>PHOSEmcRP</i>
      for EMCA and branch <i>PHOSPpsdRP</i> for PPSD.
    </p>
    <hr>
    <a NAME="Sub-Track construction"></a> 
    <h1>
      <a href="html/AliPHOSTrackSegmentMakerv1.html">Track Segments Maker</a>
    </h1>
    Each EMCA reconstructed point is either combined with one or two PPSD reconstructed points to form 
    a <a href="html/AliPHOSTrackSegment.html">track segment</a> or constitutes a track segment by itself. As a first step
    the EMCA reconstructed points are unfolded in case there is more than one local maximum ( overlapping
    showers) to make two new reconstructed points which digit's energy is shared after a fitting procedure.
    The unfolding procedure can be switch on and off with the method: <i>AliPHOSTrackSegmentMakerv1::(Un)SetUnfoldFlag()</i>.
    EMCA reconstructed points and PPSD reconstructed points are then linked together to form pairs or triplets
    according to their relative distance. Each track segment points is linked, through a mechanism described later, to the 
    reconstructed points at its origin.
    <p>
      The track segments are contained in a <a href="http://root.cern.ch/root/html/TClonesArray.html">TClonesArray</a> which are stored in <i>TreeR</i>, branch <i>PHOSTS</i>.
    </p>
    <hr>
    <a NAME="Particle identification"></a> 
   <h1>
      <a href="html/AliPHOSPIDv1.html">Particle Identification</a>
    </h1>
    Clusterization and track segments making are two activities that are <i>detector-driven</i>. This is not the case for the
    particle identification. Indeed a particle might be identified by combining the track segments calculated by several
    detectors. Up to know the implementation for such a mechanism is not yet done. Instead PHOS has its own stand alone
    particle identification algorithm which associates a <a href="html/AliPHOSRecParticle.html">reconstructed particle</a> to
    each track segment. The particle identification is controlled by several parameters which can be set by the user. Each
    reconstructed particle is linked, through a mechanism described later, to the track segment at its origin.
    The various types of reconstructed particles are the following:
    <table>
      <tr>
	<td><b>NEUTRAL</b>: </td>
	<td>a reconstructed point in EMCA, none in the two layers of the PPSD;</td>
      </tr>
      <tr>
	<td><b>GAMMA</b>  : </td>
	<td>a reconstructed point in the lower PPSD layer, none in the upper one, and a reconstructed point in
	EMCA that satisfies the shower topology cuts;</td>
      </tr>
      <tr>
	<td><b>GAMMAHADRON</b> : </td>
	<td>as a GAMMA, but the EMCA reconstructed point does not satisfy the shower topology cuts;</td>
      </tr>
      <tr>
	<td><b>CHARGED</b>:  </td>
	<td>a reconstructed point in EMCA, and one  in the upper layer of the PPSD;</td>
      </tr>
      <tr>
	<td><b>NEUTRALEM</b>: </td>
	<td>a NEUTRAL particle for which the EMCA reconstructed point satisfies the shower profile cut;</td>
      </tr>
      <tr>
	<td><b>NEUTRALHADRON</b>:</td>
	<td> a NEUTRAL particle for which the EMCA reconstructed point does not satisfy the shower profile cut;</td>
      </tr>
      <tr>
	<td><b>ELECTRON</b>: </td>
	<td>a CHARGED particle for which the EMCA reconstructed point satisfies the shower profile cut;</td>
      </tr>
      <tr>
	<td><b>CHARGEDHADRON</b>:</td>
	<td> a CHARGED particle for which the EMCA reconstructed point does not satisfy the shower profile cut;</td>
      </tr>
    </table>
    <hr>
    <a NAME="Disk Storage Structure"></a> 
    <h1>
      Disk Storage Structure
    </h1>
    All the three types of reconstructed objects( reconstructed point, track segment and reconstructed particle) are stored in
    the reconstruction Tree (<i>TreeR</i>). The container of the reconstructed points is a 
    <a href="http://root.cern.ch/root/html/TObjArray.html">TObjArray</a> and the container
    of the track segment and the reconstructed particles is a 
    <a href="http://root.cern.ch/root/html/TClonesArray.html">TClonesArray</a>. The names of the branches are respectively:
    PHOSEmcRP, PHOSPpsdRP, PHOSTS and PHOSRP. The <i>TreeR</i> is best seen in the following example: 
    <pre class="code">
      root [2] TFile myfile("junk.root")
      root [3] TTree * reconstructedtree = (TTree *)myfile.Get("TreeR0")
      root [5] reconstructedtree.Print()
      ******************************************************************************
      *Tree    :TreeR0    : Reconstruction                                         *
      *Entries :        1 : Total  Size =     10882 bytes  File  Size =       4024 *
      *        :          : Tree compression factor =   5.65                       *
      ******************************************************************************
      *Branch  :PHOSEmcRP : PHOSEmcRP                                              *
      *Entries :        1 : Total  Size =         0 bytes  File Size  =          0 *
      *Baskets :        0 : Basket Size =     16000 bytes  Compression=   1.00     *
      *............................................................................*
      *Branch  :PHOSPpsdRP : PHOSPpsdRP                                            *
      *Entries :        1 : Total  Size =      8334 bytes  File Size  =       1476 *
      *Baskets :        1 : Basket Size =     16000 bytes  Compression=   5.65     *
      *............................................................................*
      *Branch  :PHOSTS    : PHOSTS                                                 *
      *Entries :        1 : Total  Size =         0 bytes  File Size  =          0 *
      *Baskets :        0 : Basket Size =     16000 bytes  Compression=   1.00     *
      *............................................................................*
      *Branch  :PHOSRP    : PHOSRP                                                 *
      *Entries :        1 : Total  Size =         0 bytes  File Size  =          0 *
      *Entries :        1 : Total  Size =         0 bytes  File Size  =          0 *
      *Baskets :        0 : Basket Size =     16000 bytes  Compression=   1.00     *
      *............................................................................*
      root [6]                       
    </pre>
    <center>
      <img src="images/BranchesInTreeR.gif" alt="branches in reconstructed Tree">
      <p>
	<b>Figure 2: </b><i>Branches in TreeR generated by the PHOS reconstruction.
	  PHOSEmc(Ppsd)RP contains EMCA(PPSD) reconstructed points in
	  <a href="http://root.cern.ch/root/html/TObjArray.html">TObjArray</a>;
	  PHOSTS contains track segments in a 
	  <a href="http://root.cern.ch/root/html/TClonesArray.html">TClonesArray</a>; PHOSRP contains reconstructed
	  particles in a <a href="http://root.cern.ch/root/html/TClonesArray.html">TClonesArray</a>. </i>
      </p>
    </center>
    <hr>
     <a NAME="How are the links implemented"></a> 
    <h1>
      How are the links implemented ?
    </h1>
    An algorithmic class, <a href="html/AliPHOSIndexToObject.html">AliPHOSIndexToObject</a> returns a pointer to the object of
    interest given the index of its storage in the array 
    (<a href="http://root.cern.ch/root/html/TObjArray.html">TObjArray</a> or 
    <a href="http://root.cern.ch/root/html/TClonesArray.html">TClonesArray</a>). It is a singleton (only one instance of the
    object does exist at run time). It must be initialized once:
    <pre class="code">
      AliPHOS * phos = (AliPHOSv0 *)gAlice->GetDetector("PHOS") ;
      AliPHOSIndexToObject::GetInstance(phos) ; 
    </pre>
    It can then be used as follow, for example for retrieving a particle from the kine tree (<i>TreeK</i>):
    <pre class="code">
     AliPHOSIndexToObject * please = AliPHOSIndexToObject::GetInstance() ;
     Int_t index = 123 ; 
     TParticle * primaryparticle = please->GimePrimaryParticle(index) ;
    </pre>
    We shall now detail how the various reconstruction objects are linked together.
    <h4>
      Digits to primary particles
    </h4>
    <A href="html/AliPHOSDigit.html">Digits</a> have three additional data members (<i>fPrimary1(2,3)</i>) that gives the index
    of the primary particles (maximum 3) that have contributed to the formation of the digit. Remember that in PHOS a digit is
    obtained from all the hits accumulated in a single cell. 
    This is not really elegant, but because the container of digits is a 
    <a href="http://root.cern.ch/root/html/TClonesArray.html">TClonesArray</a> it is not possible
    to replace the three data members by an array of integers of variable length as all objects in a 
    <a href="http://root.cern.ch/root/html/TClonesArray.html">TClonesArray</a> must be identical. To retrieve the particles that
    have contibuted to a digit, do:
    <pre class="code">
    // initialization
          // open root file
     TFile rootfile("junk.root") ;               
          // get AliRun object
     gAlice = (AliRun *)rootfile.Get("gAlice") ;
          // get detector object
     AliPHOSv0 * phos = (AliPHOSv0 *)gAlice->GetDetector("PHOS") ;
          // get the geometry associated with the detector
     AliPHOSGeometry::GetInstance( phos->GetGeometry()->GetName(), phos->GetGeometry()->GetTitle() ) ; 
          // initializes the index to object converter
     AliPHOSIndexToObject::GetInstance(phos) ;
          // get the list of digits
     TClonesArray * digitslist = phos->Digits() ; 
          // loop over the list of digits
     TIter nextdigit(digitslist) ; 
     AliPHOSDigit * digit ; 
     TParticle * primaryparticle[3] ; 
          // get the pointer of the index to object converter
     AliPHOSIndexToObject * please = AliPHOSIndexToObject::GetInstance() ;
     while ( digit = (AliPHOSDigit * )nextdigit() ) {
       for ( Int_t i = 0 ; i < digit->GetNprimary() ; i++ ) 
       primary[i] = please->GimePrimaryParticle(digit->GetPrimary(i) ) ;
     }     
    </pre>
    <h4>
      Reconstructed point to Digit
    </h4>
    A <a href="html/AliPHOSDigit.html">digit</a> has an additional data member which is the index of the object stored
    in the  <a href="http://root.cern.ch/root/html/TObjArray.html">TObjArray</a>. It is set by 
    <a href="html/AliPHOSv0.html">FinishEvent()</a>. A <a href="html/AliPHOSRecPoint.html">reconstructed point</a> containing
    a list of digits, it can retrieve the digit object with the help of 
    <a href="html/AliPHOSIndexToObject.html">AliPHOSIndexToObject</a>:
    <pre class="code">
      // initialization
          // open root file
     TFile rootfile("junk.root") ;               
          // get AliRun object
     gAlice = (AliRun *)rootfile.Get("gAlice") ;
          // get detector object
     AliPHOSv0 * phos = (AliPHOSv0 *)gAlice->GetDetector("PHOS") ;
          // get the geometry associated with the detector
     AliPHOSGeometry::GetInstance( phos->GetGeometry()->GetName(), phos->GetGeometry()->GetTitle() ) ; 
          // initializes the index to object converter
     AliPHOSIndexToObject::GetInstance(phos) ;
          // get the reconstructed points list
     Int_t evt = 123 ; 
     TObjArray * recpointslist = phos->EmcRecPoints(evt) ; 
          // loop over reconstructed points 
     TIter nextrecpoint(recpointslist) ; 
          // get the pointer of the index to object converter
     AliPHOSIndexToObject * please = AliPHOSIndexToObject::GetInstance() ;
     AliPHOSEmcRecPoint * recpoint ;  
     while ( recpoint = (AliPHOSEmcRecPoint * )nextrecpoint() ) {
             // get the associated digits list
       Int_t * digitsindexeslist = recpoint->GetDigitsList() ;
             // loop over the list of digits
       for ( Int_t i = 0 ; i < recpoint->GetDigitsMultiplicity() ; i++ ) {
         AliPHOSDigit * digit = please->GimeDigit(digitsindexeslist[i] ) ;
               // get the primary particle associated with that digit
 	 Int_t numberofprimaries = 0 ; 
	 Int_t * prim = digit->GetPrimaries(numberofprimaries) ;
         for (Int_t i = 0 ; i < numberofprimaries ; i++ )
           // and print them 
	   please->GimePrimaryParticle( prim[i] )->Print()  ;
         } 
       } 
         // or get the primaries directly from the reconstructed point
       Int_t numberofprimaries = 0 ; 
       Int_t * prim = recpoint->GetPrimaries(numberofprimaries) ;  
     }       
    </pre>
    <h4>
      Track segment to reconstructed point 
    </h4>
    A <a href="html/AliPHOSRecPoint.html">reconstructed point</a> has an additional data member which is the index of the object stored
    in the  <a href="http://root.cern.ch/root/html/TClonesArray.html">TClnesArray</a>. It is set by the 
    <a href="html/AliPHOSReconstructioner.html">reconstructioner</a>. 
    A <a href="html/AliPHOSTrackSegment.html">track segment</a> contains the index of one EMCA reconstructed points and two 
    PPSD reconstructed points, it can retrieve this reconstructed point objects with the help of 
    <a href="html/AliPHOSIndexToObject.html">AliPHOSIndexToObject</a>:
    <pre class="code">
     // initialization
          // open root file
     TFile rootfile("junk.root") ;               
          // get AliRun object
     gAlice = (AliRun *)rootfile.Get("gAlice") ;
          // get detector object
     AliPHOSv0 * phos = (AliPHOSv0 *)gAlice->GetDetector("PHOS") ;
          // get the geometry associated with the detector
     AliPHOSGeometry::GetInstance( phos->GetGeometry()->GetName(), phos->GetGeometry()->GetTitle() ) ; 
          // initializes the index to object converter
     AliPHOSIndexToObject::GetInstance(phos) ;
          // get the track segments list
     Int_t evt = 123 ; 
     TClonesArray * tracksegmentslist = phos->TrackSegments(evt) ; 
          // loop over track segments
     TIter nexttracksegment(tracksegmentslist) ; 
     AliPHOSTrackSegment * tracksegment ;  
         // get the pointer of the index to object converter
     AliPHOSIndexToObject * please = AliPHOSIndexToObject::GetInstance() ;
     while ( tracksegment = (AliPHOSTrackSegment * )nexttracksegment() ) {
           // get the associated reconstructed points
         AliPHOSEmcRecPoint  * emcrecpoint     = please->GimeRecPoint(tracksegment->GetEmcRecPoint(),    "emc" ) ;
         AliPHOSPpsdRecPoint * ppsduprecpoint  = please->GimeRecPoint(tracksegment->GetPpsdUpRecPoint(), "ppsd" ) ;
         AliPHOSPpsdRecPoint * ppsdlowrecpoint = please->GimeRecPoint(tracksegment->GetPpsdLowRecPoint(),"ppsd" ) ;
          // get the primaries particles  
         Int_t numberofprimariestoemc = 0 ; 
         Int_t * primemc = tracksegment->GetPrimariesEmc(numberofprimariestoemc) ;
         Int_t numberofprimariestoppsdup = 0 ; 
         Int_t * primppsdup = tracksegment->GetPrimariesPpsdUp(numberofprimariestoppsdup) ;
         Int_t numberofprimariestoppsdlow = 0 ; 
         Int_t * primppsdlow = tracksegment->GetPrimariesPpsdLow(numberofprimariestoppsdlow) ;
          // print one as example  
         please->GimePrimaryParticle( primppsdlow[0] )->Print()  ;     
       }
     rootfile.Close() ;
     gAlice = 0 ; 
     phos = 0 ; 
     recparticleslist = 0 ;
     </pre>    
    <h4>
      Reconstructed particle to Track segment  
    </h4>
    A <a href="html/AliPHOSTrackSegment.html">track segment</a> has an additional data member which is the index of the object stored
    in the  <a href="http://root.cern.ch/root/html/TClonesArray.html">TClnesArray</a>. It is set by the 
    <a href="html/AliPHOSReconstructioner.html">reconstructioner</a>. 
    A <a href="html/AliPHOSRecParticle.html">reconstructed particle</a> contains the index of a track segment, 
    it can retrieve this reconstructed point objects with the help of 
    <a href="html/AliPHOSIndexToObject.html">AliPHOSIndexToObject</a>:
    <pre class="code">
     // initialization
          // open root file
     TFile rootfile("junk.root") ;               
          // get AliRun object
     gAlice = (AliRun *)rootfile.Get("gAlice") ;
          // get detector object
     AliPHOSv0 * phos = (AliPHOSv0 *)gAlice->GetDetector("PHOS") ;
          // get the geometry associated with the detector
     AliPHOSGeometry::GetInstance( phos->GetGeometry()->GetName(), phos->GetGeometry()->GetTitle() ) ; 
          // initializes the index to object converter
     AliPHOSIndexToObject::GetInstance(phos) ;
          // get the reconstructed particles list
     Int_t evt = 123 ; 
     TClonesArray * recparticleslist = phos->RecParticles(evt) ; 
     // loop over reconstructed particles
     TIter nextrecparticle(recparticleslist) ; 
     AliPHOSRecParticle * recparticle ;  
       // get the pointer of the index to object converter
     AliPHOSIndexToObject * please = AliPHOSIndexToObject::GetInstance() ;
     while ( recparticle = (AliPHOSRecParticle * )nextrecparticle() ) {
           // get the track segment ...
         AliPHOSTrackSegment  * tracksegment  = recparticle->GetPHOSTrackSegment()  ;
           // and print it
	 tracksegment->Print() ;
           // get the list of primaries ...
	 Int_t numberofprimaries = 0 ; 
	 Int_t * prim = recparticle->GetPrimaries(numberofprimaries) ;
         for (Int_t i = 0 ; i < numberofprimaries ; i++ )
           // and print them 
	   please->GimePrimaryParticle( prim[i] )->Print()  ; 
    }     
     rootfile.Close() ;
     gAlice = 0 ; 
     phos = 0 ; 
     recparticleslist = 0 ;
    </pre>
    A short cut allows to access the primaries at the origin of the reconstructed particle:
    <pre class="code">
     Int_t numberofprimaries = 0 ; 
     Int_t * prim = recparticle->GetPrimariesPpsdLow(numberofprimaries) ;
    </pre>    
<hr>
<address class="left">
&copy; <a href="mailto:schutz@in2p3.fr">Groupe Photons Subatech</a> <a href="http://www-subatech.in2p3.fr/~photons/subatech/en_index.shtml">[Go
to the GPS Home Page]</a></address>

<address class="right"> 
<!-- Created: Tue Oct 26 19:52:56 CEST 1999 -->
<!-- hhmts start -->
Last modified: Sun Mar 26 17:20:12 CEST 2000
<!-- hhmts end --></address>

<!-- <div align=right><a href="http://validator.w3.org/check/referer"><img SRC="images/vh40.gif" ALT="Valid HTML 4.0!" BORDER=0 height=31 width=88></a><a href="http://jigsaw.w3.org/css-validator"><img SRC="images/vcss.gif" ALT="Valid CSS!" BORDER=0 height=31 width=88></a></div> -->

</body>
</html>
