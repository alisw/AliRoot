\section{Ali\-HLTData\-Buffer Class Reference}
\label{classAliHLTDataBuffer}\index{AliHLTDataBuffer@{AliHLTDataBuffer}}
{\tt \#include $<$Ali\-HLTData\-Buffer.h$>$}

Inheritance diagram for Ali\-HLTData\-Buffer::\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2cm]{classAliHLTDataBuffer}
\end{center}
\end{figure}


\subsection{Detailed Description}
Handling of data buffers for the HLT. 

The class provides handling of data buffers for HLT tasks. Each task gets its own Data Buffer instance. The buffer is grouped into different data segments according to the output of the component.\par
 The Data Buffer keeps control over the data requests of the 'child' components. Each component can subscribe to a certain segment of the data buffer. It's state is then changed from 'reserved' to 'active'. After the data processing, the component has to release the segment and it's state is set to 'processed'. If all components have requested and released their data, the Raw Buffer is released and pushed back in the list of available buffers.

\begin{Desc}
\item[Note:]This class is only used for the {\bf HLT integration into Ali\-Root}{\rm (p.\,\pageref{group__alihlt__system})}. \end{Desc}




Definition at line 41 of file Ali\-HLTData\-Buffer.h.\subsection*{Public Member Functions}
\begin{CompactItemize}
\item 
{\bf Ali\-HLTData\-Buffer} ()
\item 
{\bf Ali\-HLTData\-Buffer} (const {\bf Ali\-HLTData\-Buffer} \&)
\item 
{\bf Ali\-HLTData\-Buffer} \& {\bf operator=} (const {\bf Ali\-HLTData\-Buffer} \&)
\item 
virtual {\bf $\sim$Ali\-HLTData\-Buffer} ()
\item 
int {\bf Set\-Consumer} ({\bf Ali\-HLTComponent} $\ast$p\-Consumer)
\item 
int {\bf Find\-Matching\-Data\-Blocks} (const {\bf Ali\-HLTComponent} $\ast$p\-Consumer, vector$<$ {\bf Ali\-HLTComponent\-Data\-Type} $>$ $\ast$tgt\-List=NULL)
\item 
int {\bf Subscribe} (const {\bf Ali\-HLTComponent} $\ast$p\-Consumer, {\bf Ali\-HLTComponent\-Block\-Data} $\ast$array\-Block\-Desc, int i\-Array\-Size)
\item 
int {\bf Release} ({\bf Ali\-HLTComponent\-Block\-Data} $\ast$p\-Block\-Desc, const {\bf Ali\-HLTComponent} $\ast$p\-Consumer)
\item 
{\bf Ali\-HLTUInt8\_\-t} $\ast$ {\bf Get\-Target\-Buffer} (int i\-Min\-Size)
\item 
int {\bf Set\-Segments} ({\bf Ali\-HLTUInt8\_\-t} $\ast$p\-Tgt, {\bf Ali\-HLTComponent\-Block\-Data} $\ast$array\-Segments, int i\-Size)
\item 
int {\bf Is\-Empty} ()
\item 
int {\bf Get\-Nof\-Segments} ()
\item 
int {\bf Get\-Nof\-Consumers} ()
\item 
int {\bf Get\-Nof\-Active\-Consumers} ()
\item 
int {\bf Find\-Consumer} ({\bf Ali\-HLTComponent} $\ast$p\-Consumer, int b\-All\-Lists=1)
\item 
int {\bf Reset} ()
\end{CompactItemize}
\subsection*{Private Member Functions}
\begin{CompactItemize}
\item 
int {\bf Find\-Matching\-Data\-Segments} (const {\bf Ali\-HLTComponent} $\ast$p\-Consumer, vector$<$ {\bf Ali\-HLTData\-Buffer::Ali\-HLTData\-Segment} $>$ \&tgt\-List)
\item 
int {\bf Reset\-Data\-Buffer} ()
\item 
{\bf Ali\-HLTConsumer\-Descriptor} $\ast$ {\bf Find\-Consumer} (const {\bf Ali\-HLTComponent} $\ast$p\-Consumer, vector$<$ {\bf Ali\-HLTConsumer\-Descriptor} $\ast$ $>$ \&list) const 
\begin{CompactList}\small\item\em transient/////////////////////////////////////////////////////////////////////////// \item\end{CompactList}\item 
int {\bf Change\-Consumer\-State} ({\bf Ali\-HLTConsumer\-Descriptor} $\ast$p\-Desc, vector$<$ {\bf Ali\-HLTConsumer\-Descriptor} $\ast$ $>$ \&src\-List, vector$<$ {\bf Ali\-HLTConsumer\-Descriptor} $\ast$ $>$ \&tgt\-List)
\item 
int {\bf Cleanup\-Consumer\-List} ()
\end{CompactItemize}
\subsection*{Static Private Member Functions}
\begin{CompactItemize}
\item 
{\bf Ali\-HLTRaw\-Buffer} $\ast$ {\bf Create\-Raw\-Buffer} ({\bf Ali\-HLTUInt32\_\-t} size)
\item 
int {\bf Release\-Raw\-Buffer} ({\bf Ali\-HLTRaw\-Buffer} $\ast$p\-Buffer)
\item 
int {\bf Delete\-Raw\-Buffers} ()
\end{CompactItemize}
\subsection*{Private Attributes}
\begin{CompactItemize}
\item 
vector$<$ {\bf Ali\-HLTData\-Segment} $>$ {\bf f\-Segments}
\item 
vector$<$ {\bf Ali\-HLTConsumer\-Descriptor} $\ast$ $>$ {\bf f\-Consumers}
\item 
vector$<$ {\bf Ali\-HLTConsumer\-Descriptor} $\ast$ $>$ {\bf f\-Active\-Consumers}
\item 
vector$<$ {\bf Ali\-HLTConsumer\-Descriptor} $\ast$ $>$ {\bf f\-Released\-Consumers}
\item 
{\bf Ali\-HLTRaw\-Buffer} $\ast$ {\bf fp\-Buffer}
\item 
{\bf Ali\-HLTUInt32\_\-t} {\bf f\-Flags}
\begin{CompactList}\small\item\em transient \item\end{CompactList}\end{CompactItemize}
\subsection*{Static Private Attributes}
\begin{CompactItemize}
\item 
int {\bf fg\-Nof\-Instances} = 0
\item 
vector$<$ {\bf Ali\-HLTRaw\-Buffer} $\ast$ $>$ {\bf fg\-Free\-Buffers}
\item 
vector$<$ {\bf Ali\-HLTRaw\-Buffer} $\ast$ $>$ {\bf fg\-Active\-Buffers}
\item 
{\bf Ali\-HLTUInt32\_\-t} {\bf fg\-Margin} = 1024
\item 
{\bf Ali\-HLTLogging} {\bf fg\-Logging}
\item 
const Int\_\-t {\bf fgk\-Safety\-Pattern\-Size} = 16
\item 
const char {\bf fgk\-Safety\-Pattern} [$\,$] = \{0x28, 0x63, 0x29, 0x4d, 0x52, 0x49, 0x43, 0x48, 0x54, 0x45, 0x52, 0x20, 0x32, 0x30, 0x30, 0x37\}
\end{CompactItemize}


\subsection{Constructor \& Destructor Documentation}
\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!AliHLTDataBuffer@{AliHLTDataBuffer}}
\index{AliHLTDataBuffer@{AliHLTDataBuffer}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}Ali\-HLTData\-Buffer::Ali\-HLTData\-Buffer ()}\label{classAliHLTDataBuffer_a0}


\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!AliHLTDataBuffer@{AliHLTDataBuffer}}
\index{AliHLTDataBuffer@{AliHLTDataBuffer}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}Ali\-HLTData\-Buffer::Ali\-HLTData\-Buffer (const {\bf Ali\-HLTData\-Buffer} \&)}\label{classAliHLTDataBuffer_a1}


not a valid copy constructor, defined according to effective C++ style 

Definition at line 59 of file Ali\-HLTData\-Buffer.cxx.

References HLTFatal.

\footnotesize\begin{verbatim}60   :
61   TObject(),
62   AliHLTLogging(),
63   fSegments(),
64   fConsumers(),
65   fActiveConsumers(),
66   fReleasedConsumers(),
67   fpBuffer(NULL),
68   fFlags(0)
69 {
70   // see header file for function documentation
71   HLTFatal("copy constructor untested");
72 }

\end{verbatim}\normalsize 


\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!~AliHLTDataBuffer@{$\sim$AliHLTDataBuffer}}
\index{~AliHLTDataBuffer@{$\sim$AliHLTDataBuffer}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}Ali\-HLTData\-Buffer::$\sim${\bf Ali\-HLTData\-Buffer} ()\hspace{0.3cm}{\tt  [virtual]}}\label{classAliHLTDataBuffer_a3}


destructor 

Definition at line 89 of file Ali\-HLTData\-Buffer.cxx.

References Cleanup\-Consumer\-List(), Delete\-Raw\-Buffers(), and fg\-Nof\-Instances.

\footnotesize\begin{verbatim}90 {
91   // see header file for function documentation
92   if (--fgNofInstances<=0) {
93     DeleteRawBuffers();
94   }
95   CleanupConsumerList();
96 }
\end{verbatim}\normalsize 




\subsection{Member Function Documentation}
\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!ChangeConsumerState@{ChangeConsumerState}}
\index{ChangeConsumerState@{ChangeConsumerState}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int Ali\-HLTData\-Buffer::Change\-Consumer\-State ({\bf Ali\-HLTConsumer\-Descriptor} $\ast$ {\em p\-Desc}, vector$<$ {\bf Ali\-HLTConsumer\-Descriptor} $\ast$ $>$ \& {\em src\-List}, vector$<$ {\bf Ali\-HLTConsumer\-Descriptor} $\ast$ $>$ \& {\em tgt\-List})\hspace{0.3cm}{\tt  [private]}}\label{classAliHLTDataBuffer_d3}


Change the state of a consumer. The state of a consumer is determined by the list it is strored in, the method moves a consumer from the source to the target list. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em p\-Desc}]pointer to consumer descriptor \item[{\em src\-List}]list where the consumer is currently to be found \item[{\em tgt\-List}]list where to move the consumer \end{description}
\end{Desc}


Definition at line 526 of file Ali\-HLTData\-Buffer.cxx.

References HLTError.

Referenced by Release(), and Subscribe().

\footnotesize\begin{verbatim}527 {
528   // see header file for function documentation
529   int iResult=-ENOENT;
530   if (pDesc) {
531     vector<AliHLTConsumerDescriptor*>::iterator desc=srcList.begin();
532     while (desc!=srcList.end()) {
533       if ((*desc)==pDesc) {
534         srcList.erase(desc);
535         tgtList.push_back(pDesc);
536         iResult=0;
537         break;
538       }
539       desc++;
540     }
541     if (iResult<0) {
542       HLTError("can not find consumer descriptor %p in list", pDesc);
543     }
544   } else {
545     HLTError("invalid parameter");
546     iResult=-EINVAL;
547   }
548   return iResult;
549 }
\end{verbatim}\normalsize 


\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!CleanupConsumerList@{CleanupConsumerList}}
\index{CleanupConsumerList@{CleanupConsumerList}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int Ali\-HLTData\-Buffer::Cleanup\-Consumer\-List ()\hspace{0.3cm}{\tt  [private]}}\label{classAliHLTDataBuffer_d4}


Cleanup a consumer list. Release all allocated data structures. {\bf Note:} Not the component itself! 

Definition at line 551 of file Ali\-HLTData\-Buffer.cxx.

References f\-Consumers, and Reset\-Data\-Buffer().

Referenced by $\sim$Ali\-HLTData\-Buffer().

\footnotesize\begin{verbatim}552 {
553   // see header file for function documentation
554   int iResult=0;
555   ResetDataBuffer();
556   vector<AliHLTConsumerDescriptor*>::iterator desc=fConsumers.begin();
557   while (desc!=fConsumers.end()) {
558     delete *desc;
559     fConsumers.erase(desc);
560     desc=fConsumers.begin();
561   }
562   return iResult;
563 }
\end{verbatim}\normalsize 


\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!CreateRawBuffer@{CreateRawBuffer}}
\index{CreateRawBuffer@{CreateRawBuffer}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf Ali\-HLTData\-Buffer::Ali\-HLTRaw\-Buffer} $\ast$ Ali\-HLTData\-Buffer::Create\-Raw\-Buffer ({\bf Ali\-HLTUInt32\_\-t} {\em size})\hspace{0.3cm}{\tt  [static, private]}}\label{classAliHLTDataBuffer_h0}


Create a raw buffer of a certain size. The function tries to find a buffer of the given size (or a bit bigger by a certain margin {\bf fg\-Margin}{\rm (p.\,\pageref{classAliHLTDataBuffer_v3})}) from the list of free buffers. If no buffer is available, a new one is created and added to the buffer handling. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em size}]min. size of the requested buffer \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]pointer to raw buffer \end{Desc}


Definition at line 348 of file Ali\-HLTData\-Buffer.cxx.

References fg\-Active\-Buffers, fg\-Free\-Buffers, fgk\-Safety\-Pattern, fg\-Logging, Ali\-HLTData\-Buffer::Ali\-HLTRaw\-Buffer::f\-Ptr, Ali\-HLTData\-Buffer::Ali\-HLTRaw\-Buffer::f\-Size, Ali\-HLTData\-Buffer::Ali\-HLTRaw\-Buffer::f\-Total\-Size, k\-HLTLog\-Debug, k\-HLTLog\-Error, and Ali\-HLTLogging::Logging().

Referenced by Get\-Target\-Buffer().

\footnotesize\begin{verbatim}349 {
350   // see header file for function documentation
351   AliHLTRawBuffer* pRawBuffer=NULL;
352   unsigned int reqSize=size+fgkSafetyPatternSize;
353   vector<AliHLTRawBuffer*>::iterator buffer=fgFreeBuffers.begin();
354   while (buffer!=fgFreeBuffers.end() && pRawBuffer==NULL) {
355     if ((*buffer)->fTotalSize>=reqSize && ((*buffer)->fTotalSize-reqSize)<fgMargin) {
356       // assign this element
357       pRawBuffer=*buffer;
358       pRawBuffer->fSize=size;
359       fgFreeBuffers.erase(buffer);
360       fgLogging.Logging(kHLTLogDebug, "AliHLTDataBuffer::CreateRawBuffer", "data buffer handling", "raw buffer container %p provided for request of %d bytes (total %d available in buffer %p)", pRawBuffer, size, pRawBuffer->fTotalSize, pRawBuffer->fPtr);
361       fgActiveBuffers.push_back(pRawBuffer);
362       break;
363     }
364     buffer++;
365   }
366   if (pRawBuffer==NULL) {
367     // no buffer found, create a new one
368     pRawBuffer=new AliHLTRawBuffer;
369     if (pRawBuffer) {
370       pRawBuffer->fPtr=malloc(reqSize);
371       if (pRawBuffer->fPtr) {
372         pRawBuffer->fSize=size;
373         pRawBuffer->fTotalSize=reqSize;
374         fgActiveBuffers.push_back(pRawBuffer);
375         fgLogging.Logging(kHLTLogDebug, "AliHLTDataBuffer::CreateRawBuffer", "data buffer handling", "new raw buffer %p of size %d created (container %p)", pRawBuffer->fPtr, pRawBuffer->fTotalSize, pRawBuffer);
376         if (fgkSafetyPatternSize>0) {
377           memcpy(((char*)pRawBuffer->fPtr)+pRawBuffer->fSize, fgkSafetyPattern, fgkSafetyPatternSize);
378         }
379       } else {
380         delete pRawBuffer;
381         pRawBuffer=NULL;
382         fgLogging.Logging(kHLTLogError, "AliHLTDataBuffer::CreateRawBuffer", "data buffer handling", "memory allocation failed");
383       } 
384     } else {
385       fgLogging.Logging(kHLTLogError, "AliHLTDataBuffer::CreateRawBuffer", "data buffer handling", "memory allocation failed");
386     }
387   }
388   return pRawBuffer;
389 }
\end{verbatim}\normalsize 


\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!DeleteRawBuffers@{DeleteRawBuffers}}
\index{DeleteRawBuffers@{DeleteRawBuffers}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int Ali\-HLTData\-Buffer::Delete\-Raw\-Buffers ()\hspace{0.3cm}{\tt  [static, private]}}\label{classAliHLTDataBuffer_h2}


Deletes all the raw buffers. When the last Data Buffer object is destructed, all raw data buffers are relesed. 

Definition at line 421 of file Ali\-HLTData\-Buffer.cxx.

References fg\-Active\-Buffers, fg\-Free\-Buffers, fg\-Logging, k\-HLTLog\-Warning, and Ali\-HLTLogging::Logging().

Referenced by $\sim$Ali\-HLTData\-Buffer().

\footnotesize\begin{verbatim}422 {
423   // see header file for function documentation
424   int iResult=0;
425   vector<AliHLTRawBuffer*>::iterator buffer=fgFreeBuffers.begin();
426   while (buffer!=fgFreeBuffers.end()) {
427     free((*buffer)->fPtr);
428     delete *buffer;
429     fgFreeBuffers.erase(buffer);
430     buffer=fgFreeBuffers.begin();
431   }
432   buffer=fgActiveBuffers.begin();
433   while (buffer!=fgActiveBuffers.end()) {
434     fgLogging.Logging(kHLTLogWarning, "AliHLTDataBuffer::ReleaseRawBuffer", "data buffer handling", "request to delete active raw buffer container (raw buffer %p, size %d)", (*buffer)->fPtr, (*buffer)->fTotalSize);
435     free((*buffer)->fPtr);
436     delete *buffer;
437     fgActiveBuffers.erase(buffer);
438     buffer=fgActiveBuffers.begin();
439   }
440   return iResult;
441 }
\end{verbatim}\normalsize 


\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!FindConsumer@{FindConsumer}}
\index{FindConsumer@{FindConsumer}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf Ali\-HLTConsumer\-Descriptor} $\ast$ Ali\-HLTData\-Buffer::Find\-Consumer (const {\bf Ali\-HLTComponent} $\ast$ {\em p\-Consumer}, vector$<$ {\bf Ali\-HLTConsumer\-Descriptor} $\ast$ $>$ \& {\em list}) const\hspace{0.3cm}{\tt  [private]}}\label{classAliHLTDataBuffer_d2}


transient/////////////////////////////////////////////////////////////////////////// 

Find the consumer descriptor for a certain component and data type in a list of consumers.\par
 {\bf Note:} There are three lists which contain the consumers in the different states. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em p\-Consumer}]pointer to consumer component \item[{\em list}]list where to search for the consumer \end{description}
\end{Desc}


Definition at line 443 of file Ali\-HLTData\-Buffer.cxx.

\footnotesize\begin{verbatim}444 {
445   // see header file for function documentation
446   AliHLTConsumerDescriptor* pDesc=NULL;
447   vector<AliHLTConsumerDescriptor*>::iterator desc=list.begin();
448   while (desc!=list.end() && pDesc==NULL) {
449     if ((pConsumer==NULL || (*desc)->GetComponent()==pConsumer)) {
450       pDesc=*desc;
451     }
452     desc++;
453   }
454   return pDesc;
455 }
\end{verbatim}\normalsize 


\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!FindConsumer@{FindConsumer}}
\index{FindConsumer@{FindConsumer}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int Ali\-HLTData\-Buffer::Find\-Consumer ({\bf Ali\-HLTComponent} $\ast$ {\em p\-Consumer}, int {\em b\-All\-Lists} = {\tt 1})}\label{classAliHLTDataBuffer_a14}


Check if a consumer is already in the list \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em p\-Consumer}]pointer to consumer component \item[{\em b\-All\-Lists}]search in all lists if 1 search only in f\-Consumer list if 0 \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]1 if found, 0 if not \end{Desc}


Definition at line 565 of file Ali\-HLTData\-Buffer.cxx.

References f\-Active\-Consumers, f\-Consumers, and f\-Released\-Consumers.

Referenced by Release(), Set\-Consumer(), and Subscribe().

\footnotesize\begin{verbatim}566 {
567   // see header file for function documentation
568   vector<AliHLTConsumerDescriptor*>::iterator desc=fConsumers.begin();
569   while (desc!=fConsumers.end()) {
570     if ((*desc)->GetComponent()==pConsumer)
571       return 1;
572     desc++;
573   }
574   if (bAllLists==0) return 0;
575 
576   desc=fActiveConsumers.begin();
577   while (desc!=fActiveConsumers.end()) {
578     if ((*desc)->GetComponent()==pConsumer)
579       return 1;
580     desc++;
581   }
582   desc=fReleasedConsumers.begin();
583   while (desc!=fReleasedConsumers.end()) {
584     if ((*desc)->GetComponent()==pConsumer)
585       return 1;
586     desc++;
587   }
588   return 0;
589 }
\end{verbatim}\normalsize 


\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!FindMatchingDataBlocks@{FindMatchingDataBlocks}}
\index{FindMatchingDataBlocks@{FindMatchingDataBlocks}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int Ali\-HLTData\-Buffer::Find\-Matching\-Data\-Blocks (const {\bf Ali\-HLTComponent} $\ast$ {\em p\-Consumer}, vector$<$ {\bf Ali\-HLTComponent\-Data\-Type} $>$ $\ast$ {\em tgt\-List} = {\tt NULL})}\label{classAliHLTDataBuffer_a5}


Determine the number of matching data blocks for the component and a consumer component. \par
 The first approach will support only one output data type for processing components. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em p\-Consumer}]the component which subscribes to the buffer \item[{\em tgt\-List}](optional) the list to receive the data types \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]: number of data blocks which match the input data types of the consumer, neg. error code if failed \par
 -EINVAL invalid parameter \par
 \end{Desc}


Definition at line 121 of file Ali\-HLTData\-Buffer.cxx.

References Find\-Matching\-Data\-Segments().

Referenced by Ali\-HLTTask::Get\-Nof\-Matching\-Data\-Blocks().

\footnotesize\begin{verbatim}122 {
123   // see header file for function documentation
124   int iResult=0;
125   if (pConsumer) {
126     vector<AliHLTDataBuffer::AliHLTDataSegment> segments;
127     if ((iResult=FindMatchingDataSegments(pConsumer, segments))>=0) {
128       if (tgtList) {
129         vector<AliHLTDataBuffer::AliHLTDataSegment>::iterator segment=segments.begin();
130         while (segment!=segments.end()) {
131           tgtList->push_back((*segment).fDataType);
132           segment++;
133         }
134       }
135       iResult=segments.size();
136     }
137   } else {
138     iResult=-EINVAL;
139   }
140   return iResult;
141 }
\end{verbatim}\normalsize 


\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!FindMatchingDataSegments@{FindMatchingDataSegments}}
\index{FindMatchingDataSegments@{FindMatchingDataSegments}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int Ali\-HLTData\-Buffer::Find\-Matching\-Data\-Segments (const {\bf Ali\-HLTComponent} $\ast$ {\em p\-Consumer}, vector$<$ {\bf Ali\-HLTData\-Buffer::Ali\-HLTData\-Segment} $>$ \& {\em tgt\-List})\hspace{0.3cm}{\tt  [private]}}\label{classAliHLTDataBuffer_d0}


Find those data segments which match the input types of a component. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em p\-Consumer}]the component which subscribes to the buffer \item[{\em tgt\-List}]the list to receive the data segment descriptors \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]: number of data blocks which match the input data types of the consumer, neg. error code if failed \par
 -EINVAL invalid parameter \par
 \end{Desc}


Definition at line 143 of file Ali\-HLTData\-Buffer.cxx.

References f\-Segments.

Referenced by Find\-Matching\-Data\-Blocks(), and Subscribe().

\footnotesize\begin{verbatim}144 {
145   // see header file for function documentation
146   int iResult=0;
147   if (pConsumer) {
148     vector<AliHLTComponentDataType> dtlist;
149     ((AliHLTComponent*)pConsumer)->GetInputDataTypes(dtlist);
150     vector<AliHLTDataBuffer::AliHLTDataSegment>::iterator segment=fSegments.begin();
151     while (segment!=fSegments.end()) {
152       vector<AliHLTComponentDataType>::iterator type=dtlist.begin();
153       while (type!=dtlist.end()) {
154         if ((*segment).fDataType==(*type) ||
155             (*type)==kAliHLTAnyDataType) {
156           tgtList.push_back(*segment);
157           iResult++;
158           break;
159         }
160         type++;
161       }
162       segment++;
163     }
164   } else {
165     iResult=-EINVAL;
166   }
167   return iResult;
168 }
\end{verbatim}\normalsize 


\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!GetNofActiveConsumers@{GetNofActiveConsumers}}
\index{GetNofActiveConsumers@{GetNofActiveConsumers}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int Ali\-HLTData\-Buffer::Get\-Nof\-Active\-Consumers ()}\label{classAliHLTDataBuffer_a13}


Get the number of active consumers \begin{Desc}
\item[Returns:]number of active consumers \end{Desc}


Definition at line 341 of file Ali\-HLTData\-Buffer.cxx.

References f\-Active\-Consumers.

Referenced by Get\-Nof\-Consumers(), and Release().

\footnotesize\begin{verbatim}342 {
343   // see header file for function documentation
344   int iResult=fActiveConsumers.size();
345   return iResult;
346 }
\end{verbatim}\normalsize 


\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!GetNofConsumers@{GetNofConsumers}}
\index{GetNofConsumers@{GetNofConsumers}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int Ali\-HLTData\-Buffer::Get\-Nof\-Consumers ()}\label{classAliHLTDataBuffer_a12}


Get the number of consumers \begin{Desc}
\item[Returns:]number of consumers \end{Desc}


Definition at line 334 of file Ali\-HLTData\-Buffer.cxx.

References f\-Consumers, f\-Released\-Consumers, and Get\-Nof\-Active\-Consumers().

\footnotesize\begin{verbatim}335 {
336   // see header file for function documentation
337   int iResult=fConsumers.size() + GetNofActiveConsumers() + fReleasedConsumers.size();
338   return iResult;
339 }
\end{verbatim}\normalsize 


\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!GetNofSegments@{GetNofSegments}}
\index{GetNofSegments@{GetNofSegments}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int Ali\-HLTData\-Buffer::Get\-Nof\-Segments ()}\label{classAliHLTDataBuffer_a11}


Get the number of segments \begin{Desc}
\item[Returns:]number of segments \end{Desc}


Definition at line 327 of file Ali\-HLTData\-Buffer.cxx.

References f\-Segments.

Referenced by Is\-Empty().

\footnotesize\begin{verbatim}328 {
329   // see header file for function documentation
330   int iResult=fSegments.size();
331   return iResult;
332 }
\end{verbatim}\normalsize 


\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!GetTargetBuffer@{GetTargetBuffer}}
\index{GetTargetBuffer@{GetTargetBuffer}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf Ali\-HLTUInt8\_\-t} $\ast$ Ali\-HLTData\-Buffer::Get\-Target\-Buffer (int {\em i\-Min\-Size})}\label{classAliHLTDataBuffer_a8}


Get a target buffer of minimum size i\-Min\-Size. The method is used by the component which owns the Data Buffer to allocate a buffer for the data it is going to produce. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em i\-Min\-Size}]minumum size of the requested buffer \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]: pointer to target buffer if \end{Desc}


Definition at line 270 of file Ali\-HLTData\-Buffer.cxx.

References Ali\-HLTUInt8\_\-t, Create\-Raw\-Buffer(), fp\-Buffer, Ali\-HLTData\-Buffer::Ali\-HLTRaw\-Buffer::f\-Ptr, and HLTError.

Referenced by Ali\-HLTTask::Process\-Task().

\footnotesize\begin{verbatim}271 {
272   // see header file for function documentation
273   AliHLTUInt8_t* pTargetBuffer=NULL;
274   fpBuffer=CreateRawBuffer(iMinSize);
275   if (fpBuffer) {
276     pTargetBuffer=(AliHLTUInt8_t*)fpBuffer->fPtr;
277   } else {
278     HLTError("can not create raw buffer");
279   }
280   return pTargetBuffer;
281 }
\end{verbatim}\normalsize 


\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!IsEmpty@{IsEmpty}}
\index{IsEmpty@{IsEmpty}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int Ali\-HLTData\-Buffer::Is\-Empty ()}\label{classAliHLTDataBuffer_a10}


Check if the data buffer is empty. \begin{Desc}
\item[Returns:]1 if empty, 0 if not \end{Desc}


Definition at line 320 of file Ali\-HLTData\-Buffer.cxx.

References fp\-Buffer, and Get\-Nof\-Segments().

\footnotesize\begin{verbatim}321 {
322   // see header file for function documentation
323   int iResult=fpBuffer==NULL || GetNofSegments()==0;
324   return iResult;
325 }
\end{verbatim}\normalsize 


\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!operator=@{operator=}}
\index{operator=@{operator=}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf Ali\-HLTData\-Buffer} \& Ali\-HLTData\-Buffer::operator= (const {\bf Ali\-HLTData\-Buffer} \&)}\label{classAliHLTDataBuffer_a2}


not a valid assignment op, but defined according to effective C++ style 

Definition at line 74 of file Ali\-HLTData\-Buffer.cxx.

References HLTFatal.

\footnotesize\begin{verbatim}75 { 
76   // see header file for function documentation
77   HLTFatal("assignment operator untested");
78   return *this;
79 }
\end{verbatim}\normalsize 


\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!Release@{Release}}
\index{Release@{Release}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int Ali\-HLTData\-Buffer::Release ({\bf Ali\-HLTComponent\-Block\-Data} $\ast$ {\em p\-Block\-Desc}, const {\bf Ali\-HLTComponent} $\ast$ {\em p\-Consumer})}\label{classAliHLTDataBuffer_a7}


Release an instance of the data buffer. Resets the variables of the block descriptor. If all buffer segments are released, the Data Buffer is reseted and the Raw Buffer released.\par
 The method is used by the consumer component. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em p\-Block\-Desc}]descriptor of the data segment \item[{\em p\-Consumer}]the component which subscribes to the buffer \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]: $>$0 if success, negative error code if failed \par
 -EACCESS the consumer state can not be changed (de-activated) -ENOENT consumer has not subscribed to the buffer \par
 -EINVAL invalid parameter \par
 \end{Desc}


Definition at line 231 of file Ali\-HLTData\-Buffer.cxx.

References Change\-Consumer\-State(), Ali\-HLTConsumer\-Descriptor::Check\-Active\-Data\-Segment(), f\-Active\-Consumers, Find\-Consumer(), Ali\-HLTComponent\-Block\-Data::f\-Offset, Ali\-HLTComponent\-Block\-Data::f\-Ptr, f\-Released\-Consumers, Ali\-HLTComponent\-Block\-Data::f\-Size, Get\-Nof\-Active\-Consumers(), Ali\-HLTConsumer\-Descriptor::Get\-Nof\-Active\-Segments(), HLTError, HLTWarning, Ali\-HLTConsumer\-Descriptor::Release\-Active\-Data\-Segment(), and Reset\-Data\-Buffer().

Referenced by Ali\-HLTTask::Release().

\footnotesize\begin{verbatim}232 {
233   // see header file for function documentation
234   int iResult=0;
235   if (pBlockDesc && pConsumer) {
236     AliHLTConsumerDescriptor* pDesc=FindConsumer(pConsumer, fActiveConsumers);
237     if (pDesc) {
238       if ((iResult=pDesc->CheckActiveDataSegment(pBlockDesc->fOffset, pBlockDesc->fSize))!=1) {
239         HLTWarning("data segment missmatch, component %p has not subscribed to a segment with offset %#x and size %d", pConsumer, pBlockDesc->fOffset, pBlockDesc->fSize);
240         // TODO: appropriate error handling, but so far optional
241         iResult=0;
242       } else {
243         pDesc->ReleaseActiveDataSegment(pBlockDesc->fOffset, pBlockDesc->fSize);
244         pBlockDesc->fOffset=0;
245         pBlockDesc->fPtr=NULL;
246         pBlockDesc->fSize=0;
247       }
248       if (pDesc->GetNofActiveSegments()==0) {
249         if ((iResult=ChangeConsumerState(pDesc, fActiveConsumers, fReleasedConsumers))>=0) {
250           if (GetNofActiveConsumers()==0) {
251             // this is the last consumer, reset the consumer list and release the raw buffer
252             ResetDataBuffer();
253           }
254         } else {
255           HLTError("can not deactivate consumer %p for data buffer %p", pConsumer, this);
256           iResult=-EACCES;
257         }
258       }
259     } else {
260       HLTWarning("component %p has currently not subscribed to the data buffer %p", pConsumer, this);
261       iResult=-ENOENT;
262     }
263   } else {
264     HLTError("inavalid parameter: pBlockDesc=%p pConsumer=%p", pBlockDesc, pConsumer);
265     iResult=-EINVAL;
266   }
267   return iResult;
268 }
\end{verbatim}\normalsize 


\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!ReleaseRawBuffer@{ReleaseRawBuffer}}
\index{ReleaseRawBuffer@{ReleaseRawBuffer}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int Ali\-HLTData\-Buffer::Release\-Raw\-Buffer ({\bf Ali\-HLTRaw\-Buffer} $\ast$ {\em p\-Buffer})\hspace{0.3cm}{\tt  [static, private]}}\label{classAliHLTDataBuffer_h1}


Mark a buffer as free. After the Data Buffer has finnished using the raw buffer, it is released and added to the list of available buffers. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em p\-Buffer}]the raw buffer to release \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]$>$=0 if succeeded, neg. error code if failed \end{Desc}


Definition at line 391 of file Ali\-HLTData\-Buffer.cxx.

References fg\-Active\-Buffers, fg\-Free\-Buffers, fgk\-Safety\-Pattern, fgk\-Safety\-Pattern\-Size, fg\-Logging, k\-HLTLog\-Error, k\-HLTLog\-Fatal, k\-HLTLog\-Warning, and Ali\-HLTLogging::Logging().

Referenced by Reset\-Data\-Buffer().

\footnotesize\begin{verbatim}392 {
393   // see header file for function documentation
394   int iResult=0;
395   if (pBuffer) {
396     vector<AliHLTRawBuffer*>::iterator buffer=fgActiveBuffers.begin();
397     while (buffer!=fgActiveBuffers.end() && (*buffer)!=pBuffer) {
398       buffer++;
399     }
400     if (buffer!=fgActiveBuffers.end()) {
401       if (fgkSafetyPatternSize>0) {
402         if (memcmp(((char*)(*buffer)->fPtr)+(*buffer)->fSize, fgkSafetyPattern, fgkSafetyPatternSize)!=0) {
403           fgLogging.Logging(kHLTLogFatal, "AliHLTDataBuffer::ReleaseRawBuffer", "data buffer handling", "component has written beyond end of data buffer %p size %d", (*buffer)->fPtr, (*buffer)->fSize);
404         }
405       }
406       (*buffer)->fSize=0;
407       fgFreeBuffers.push_back(*buffer);
408       fgActiveBuffers.erase(buffer);
409     } else {
410       fgLogging.Logging(kHLTLogWarning, "AliHLTDataBuffer::ReleaseRawBuffer", "data buffer handling", "can not find raw buffer container %p in the list of active containers", pBuffer);
411       iResult=-ENOENT;
412     }
413   } else {
414     fgLogging.Logging(kHLTLogError, "AliHLTDataBuffer::ReleaseRawBuffer", "data buffer handling", "invalid parameter");
415     iResult=-EINVAL;
416   }
417   return iResult;
418 }
\end{verbatim}\normalsize 


\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!Reset@{Reset}}
\index{Reset@{Reset}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int Ali\-HLTData\-Buffer::Reset ()}\label{classAliHLTDataBuffer_a15}


Public method to reset the buffer. Eventually with some additional checks. In normal operation, an external reset should not be necessary. 

Definition at line 495 of file Ali\-HLTData\-Buffer.cxx.

References Reset\-Data\-Buffer().

Referenced by Ali\-HLTTask::Process\-Task().

\footnotesize\begin{verbatim}496 {
497   // see header file for function documentation
498   return ResetDataBuffer();
499 }
\end{verbatim}\normalsize 


\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!ResetDataBuffer@{ResetDataBuffer}}
\index{ResetDataBuffer@{ResetDataBuffer}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int Ali\-HLTData\-Buffer::Reset\-Data\-Buffer ()\hspace{0.3cm}{\tt  [private]}}\label{classAliHLTDataBuffer_d1}


Reset the data buffer. Removes all consumers back to the {\bf f\-Consumers}{\rm (p.\,\pageref{classAliHLTDataBuffer_r1})} list, deletes segments and releases the Raw Buffer. 

Definition at line 457 of file Ali\-HLTData\-Buffer.cxx.

References f\-Active\-Consumers, f\-Consumers, fp\-Buffer, f\-Released\-Consumers, f\-Segments, HLTWarning, and Release\-Raw\-Buffer().

Referenced by Cleanup\-Consumer\-List(), Release(), and Reset().

\footnotesize\begin{verbatim}458 {
459   // see header file for function documentation
460   int iResult=0;
461   AliHLTRawBuffer* pBuffer=fpBuffer;
462   fpBuffer=NULL;
463 
464   // cleanup consumer states
465   vector<AliHLTConsumerDescriptor*>::iterator desc=fReleasedConsumers.begin();
466   while (desc!=fReleasedConsumers.end()) {
467     AliHLTConsumerDescriptor* pDesc=*desc;
468     fReleasedConsumers.erase(desc);
469     desc=fReleasedConsumers.begin();
470     fConsumers.push_back(pDesc);
471   }
472   desc=fActiveConsumers.begin();
473   while (desc!=fActiveConsumers.end()) {
474     AliHLTConsumerDescriptor* pDesc=*desc;
475     HLTWarning("consumer %p was not released", pDesc);
476     fActiveConsumers.erase(desc);
477     desc=fActiveConsumers.begin();
478     fConsumers.push_back(pDesc);
479   }
480 
481   // cleanup segments
482   vector<AliHLTDataBuffer::AliHLTDataSegment>::iterator segment=fSegments.begin();
483   while (segment!=fSegments.end()) {
484     fSegments.erase(segment);
485     segment=fSegments.begin();
486   }
487 
488   // cleanup raw buffer
489   if (pBuffer) {
490     ReleaseRawBuffer(pBuffer);
491   }
492   return iResult;
493 }
\end{verbatim}\normalsize 


\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!SetConsumer@{SetConsumer}}
\index{SetConsumer@{SetConsumer}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int Ali\-HLTData\-Buffer::Set\-Consumer ({\bf Ali\-HLTComponent} $\ast$ {\em p\-Consumer})}\label{classAliHLTDataBuffer_a4}


Add component to the list of consumers \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em p\-Consumer}]- a consumer of type {\bf Ali\-HLTComponent}{\rm (p.\,\pageref{classAliHLTComponent})} \end{description}
\end{Desc}


Definition at line 98 of file Ali\-HLTData\-Buffer.cxx.

References f\-Consumers, Find\-Consumer(), Ali\-HLTComponent::Get\-Component\-ID(), HLTDebug, HLTError, and HLTWarning.

Referenced by Ali\-HLTTask::Start\-Run().

\footnotesize\begin{verbatim}99 {
100   // see header file for function documentation
101   int iResult=0;
102   if (pConsumer) {
103     if (FindConsumer(pConsumer)) {
104       HLTWarning("consumer %s (%p) already set to data buffer %p", pConsumer->GetComponentID(), pConsumer, this);
105     }
106     AliHLTConsumerDescriptor* pDesc=new AliHLTConsumerDescriptor(pConsumer);
107     if (pDesc) {
108       fConsumers.push_back(pDesc);
109       HLTDebug("set consumer %s (%p) to data buffer %p", pConsumer->GetComponentID(), pConsumer, this);
110     } else {
111       HLTError("memory allocation failed");
112       iResult=-ENOMEM;
113     }
114   } else {
115     HLTError("invalid parameter: consumer component (nil)");
116     iResult=-EINVAL;
117   }
118   return iResult;
119 }
\end{verbatim}\normalsize 


\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!SetSegments@{SetSegments}}
\index{SetSegments@{SetSegments}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int Ali\-HLTData\-Buffer::Set\-Segments ({\bf Ali\-HLTUInt8\_\-t} $\ast$ {\em p\-Tgt}, {\bf Ali\-HLTComponent\-Block\-Data} $\ast$ {\em array\-Segments}, int {\em i\-Size})}\label{classAliHLTDataBuffer_a9}


Set the segments for the data buffer. This is usually done after the component has written the data to the buffer, which was requested by the {\bf Get\-Target\-Buffer}{\rm (p.\,\pageref{classAliHLTDataBuffer_a8})} method. The component might produce different types of data, for each type a segment has to be defined which describes the data inside the buffer.\par
 The {\bf Ali\-HLTComponent\-Block\-Data}{\rm (p.\,\pageref{structAliHLTComponentBlockData})} segment descriptor comes directly from the {\bf Ali\-HLTComponent::Process\-Event}{\rm (p.\,\pageref{classAliHLTComponent_a6})} method. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em p\-Tgt}]the target buffer which the segments refer to \item[{\em array\-Segments}]the output block descriptors of the component \item[{\em i\-Size}]size of the array \end{description}
\end{Desc}


Definition at line 283 of file Ali\-HLTData\-Buffer.cxx.

References Ali\-HLTComponent\-Block\-Data::f\-Data\-Type, Ali\-HLTData\-Buffer::Ali\-HLTData\-Segment::f\-Data\-Type, Ali\-HLTComponent\-Block\-Data::f\-Offset, fp\-Buffer, Ali\-HLTData\-Buffer::Ali\-HLTRaw\-Buffer::f\-Ptr, Ali\-HLTData\-Buffer::Ali\-HLTData\-Segment::f\-Segment\-Offset, f\-Segments, Ali\-HLTData\-Buffer::Ali\-HLTData\-Segment::f\-Segment\-Size, Ali\-HLTData\-Buffer::Ali\-HLTRaw\-Buffer::f\-Size, Ali\-HLTComponent\-Block\-Data::f\-Size, Ali\-HLTComponent\-Block\-Data::f\-Specification, Ali\-HLTData\-Buffer::Ali\-HLTData\-Segment::f\-Specification, HLTDebug, HLTError, and HLTFatal.

Referenced by Ali\-HLTTask::Process\-Task().

\footnotesize\begin{verbatim}284 {
285   // see header file for function documentation
286   int iResult=0;
287   if (pTgt && arrayBlockData && iSize>=0) {
288     if (fpBuffer) {
289       if (fpBuffer->fPtr==(void*)pTgt) {
290         AliHLTDataBuffer::AliHLTDataSegment segment;
291         for (int i=0; i<iSize; i++) {
292           if (arrayBlockData[i].fOffset+arrayBlockData[i].fSize<=fpBuffer->fSize) {
293             segment.fSegmentOffset=arrayBlockData[i].fOffset;
294             segment.fSegmentSize=arrayBlockData[i].fSize;
295             segment.fDataType=arrayBlockData[i].fDataType;
296             segment.fSpecification=arrayBlockData[i].fSpecification;
297             fSegments.push_back(segment);
298             HLTDebug("set segment %s with size %d at offset %d", AliHLTComponent::DataType2Text(segment.fDataType).data(), segment.fSegmentSize, segment.fSegmentOffset);
299           } else {
300             HLTError("block data specification %#d (%s) exceeds size of data buffer", i, AliHLTComponent::DataType2Text(arrayBlockData[i].fDataType).data());
301             HLTError("block offset=%d, block size=%d, buffer size=%d", arrayBlockData[i].fOffset, arrayBlockData[i].fSize, fpBuffer->fSize);
302             iResult=-E2BIG;
303           }
304         }
305       } else {
306         HLTError("this data buffer (%p) does not match the internal data buffer %p of raw buffer %p", pTgt, fpBuffer->fPtr, fpBuffer);
307         iResult=-EINVAL;
308       }
309     } else {
310       HLTFatal("internal data structur missmatch");
311       iResult=-EFAULT;
312     }
313   } else {
314     HLTError("invalid parameter: pTgtBuffer=%p arrayBlockData=%p", pTgt, arrayBlockData);
315     iResult=-EINVAL;
316   }
317   return iResult;
318 }
\end{verbatim}\normalsize 


\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!Subscribe@{Subscribe}}
\index{Subscribe@{Subscribe}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int Ali\-HLTData\-Buffer::Subscribe (const {\bf Ali\-HLTComponent} $\ast$ {\em p\-Consumer}, {\bf Ali\-HLTComponent\-Block\-Data} $\ast$ {\em array\-Block\-Desc}, int {\em i\-Array\-Size})}\label{classAliHLTDataBuffer_a6}


Subscribe to a segment of the data buffer. The function prepares the block descriptor for subsequent use with the {\bf Ali\-HLTComponent::Process\-Event}{\rm (p.\,\pageref{classAliHLTComponent_a6})} method, the method can prepare several block descriptors up to the array size specified by i\-Array\-Size. The return value is independent from the array size the number of block descriptors which would have been prepared if there was enough space in the array\par
 The method is used by the consumer component. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em p\-Consumer}]the component which subscribes to the buffer \item[{\em array\-Block\-Desc}]pointer to block descriptor to be filled \item[{\em i\-Array\-Size}]size of the block descriptor array \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]: number of matching data blocks, neg. error code if failed\par
 -EACCESS the consumer state can't be changed (activated) -EBADF unresolved data segments \par
 -ENOENT consumer component not found \par
 -ENODATA data buffer does not have raw data \par
 -EINVAL invalid parameter \par
 \end{Desc}


Definition at line 170 of file Ali\-HLTData\-Buffer.cxx.

References Change\-Consumer\-State(), f\-Active\-Consumers, f\-Consumers, Ali\-HLTComponent\-Block\-Data::f\-Data\-Type, Find\-Consumer(), Find\-Matching\-Data\-Segments(), Ali\-HLTComponent\-Block\-Data::f\-Offset, fp\-Buffer, Ali\-HLTData\-Buffer::Ali\-HLTRaw\-Buffer::f\-Ptr, Ali\-HLTComponent\-Block\-Data::f\-Ptr, Ali\-HLTComponent\-Shm\-Data::f\-Shm\-ID, Ali\-HLTComponent\-Block\-Data::f\-Shm\-Key, Ali\-HLTComponent\-Shm\-Data::f\-Shm\-Type, Ali\-HLTComponent\-Block\-Data::f\-Size, Ali\-HLTComponent\-Block\-Data::f\-Specification, Ali\-HLTComponent\-Shm\-Data::f\-Struct\-Size, Ali\-HLTComponent\-Block\-Data::f\-Struct\-Size, HLTDebug, HLTError, and Ali\-HLTConsumer\-Descriptor::Set\-Active\-Data\-Segment().

Referenced by Ali\-HLTTask::Subscribe().

\footnotesize\begin{verbatim}171 {
172   // see header file for function documentation
173   int iResult=0;
174   if (pConsumer && arrayBlockDesc) {
175     if (fpBuffer) {
176       AliHLTConsumerDescriptor* pDesc=FindConsumer(pConsumer, fConsumers);
177       if (pDesc) {
178         vector<AliHLTDataBuffer::AliHLTDataSegment> tgtList;
179         /* TODO: think about a good policy for this check
180          * is it enough that at least one segment is available, or have all to be available?
181          * or is it possible to have optional segments?
182          */
183         if ((iResult=FindMatchingDataSegments(pConsumer, tgtList))>0) {
184           int i =0;
185           vector<AliHLTDataBuffer::AliHLTDataSegment>::iterator segment=tgtList.begin();
186           while (segment!=tgtList.end() && i<iArraySize) {
187             // fill the block data descriptor
188             arrayBlockDesc[i].fStructSize=sizeof(AliHLTComponentBlockData);
189             // the shared memory key is not used in AliRoot
190             arrayBlockDesc[i].fShmKey.fStructSize=sizeof(AliHLTComponentShmData);
191             arrayBlockDesc[i].fShmKey.fShmType=gkAliHLTComponentInvalidShmType;
192             arrayBlockDesc[i].fShmKey.fShmID=gkAliHLTComponentInvalidShmID;
193             arrayBlockDesc[i].fOffset=(*segment).fSegmentOffset;
194             arrayBlockDesc[i].fPtr=fpBuffer->fPtr;
195             arrayBlockDesc[i].fSize=(*segment).fSegmentSize;
196             arrayBlockDesc[i].fDataType=(*segment).fDataType;
197             arrayBlockDesc[i].fSpecification=(*segment).fSpecification;
198             pDesc->SetActiveDataSegment(arrayBlockDesc[i].fOffset, arrayBlockDesc[i].fSize);
199             HLTDebug("component %p (%s) subscribed to segment #%d offset %d", pConsumer, ((AliHLTComponent*)pConsumer)->GetComponentID(), i, arrayBlockDesc[i].fOffset);
200             i++;
201             segment++;
202           }
203           // move this consumer to the active list
204           if (ChangeConsumerState(pDesc, fConsumers, fActiveConsumers)>=0) {
205             HLTDebug("component %p (%s) subscribed to data buffer %p", pConsumer, ((AliHLTComponent*)pConsumer)->GetComponentID(), this);
206           } else {
207             // TODO: cleanup the consumer descriptor correctly
208             memset(arrayBlockDesc, 0, iArraySize*sizeof(AliHLTComponentBlockData));
209             HLTError("can not activate consumer %p for data buffer %p", pConsumer, this);
210             iResult=-EACCES;
211           }
212         } else {
213           HLTError("unresolved data segment(s) for component %p (%s)", pConsumer, ((AliHLTComponent*)pConsumer)->GetComponentID());
214           iResult=-EBADF;
215         }
216       } else {
217         HLTError("component %p is not a data consumer of data buffer %s", pConsumer, this);
218         iResult=-ENOENT;
219       }
220     } else {
221       HLTError("data buffer %p is empty", this);
222       iResult=-ENODATA;
223     }
224   } else {
225     HLTError("invalid parameter");
226     iResult=-EINVAL;
227   }
228   return iResult;
229 }
\end{verbatim}\normalsize 




\subsection{Member Data Documentation}
\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!fActiveConsumers@{fActiveConsumers}}
\index{fActiveConsumers@{fActiveConsumers}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}vector$<${\bf Ali\-HLTConsumer\-Descriptor}$\ast$$>$ {\bf Ali\-HLTData\-Buffer::f\-Active\-Consumers}\hspace{0.3cm}{\tt  [private]}}\label{classAliHLTDataBuffer_r2}




Definition at line 283 of file Ali\-HLTData\-Buffer.h.

Referenced by Find\-Consumer(), Get\-Nof\-Active\-Consumers(), Release(), Reset\-Data\-Buffer(), and Subscribe().\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!fConsumers@{fConsumers}}
\index{fConsumers@{fConsumers}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}vector$<${\bf Ali\-HLTConsumer\-Descriptor}$\ast$$>$ {\bf Ali\-HLTData\-Buffer::f\-Consumers}\hspace{0.3cm}{\tt  [private]}}\label{classAliHLTDataBuffer_r1}




Definition at line 281 of file Ali\-HLTData\-Buffer.h.

Referenced by Cleanup\-Consumer\-List(), Find\-Consumer(), Get\-Nof\-Consumers(), Reset\-Data\-Buffer(), Set\-Consumer(), and Subscribe().\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!fFlags@{fFlags}}
\index{fFlags@{fFlags}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf Ali\-HLTUInt32\_\-t} {\bf Ali\-HLTData\-Buffer::f\-Flags}\hspace{0.3cm}{\tt  [private]}}\label{classAliHLTDataBuffer_r5}


transient 



Definition at line 291 of file Ali\-HLTData\-Buffer.h.\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!fgActiveBuffers@{fgActiveBuffers}}
\index{fgActiveBuffers@{fgActiveBuffers}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}vector$<$ {\bf Ali\-HLTData\-Buffer::Ali\-HLTRaw\-Buffer} $\ast$ $>$ {\bf Ali\-HLTData\-Buffer::fg\-Active\-Buffers}\hspace{0.3cm}{\tt  [static, private]}}\label{classAliHLTDataBuffer_v2}


global list of currently active raw buffers 

Definition at line 83 of file Ali\-HLTData\-Buffer.cxx.

Referenced by Create\-Raw\-Buffer(), Delete\-Raw\-Buffers(), and Release\-Raw\-Buffer().\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!fgFreeBuffers@{fgFreeBuffers}}
\index{fgFreeBuffers@{fgFreeBuffers}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}vector$<$ {\bf Ali\-HLTData\-Buffer::Ali\-HLTRaw\-Buffer} $\ast$ $>$ {\bf Ali\-HLTData\-Buffer::fg\-Free\-Buffers}\hspace{0.3cm}{\tt  [static, private]}}\label{classAliHLTDataBuffer_v1}


global list of free raw buffers 

Definition at line 82 of file Ali\-HLTData\-Buffer.cxx.

Referenced by Create\-Raw\-Buffer(), Delete\-Raw\-Buffers(), and Release\-Raw\-Buffer().\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!fgkSafetyPattern@{fgkSafetyPattern}}
\index{fgkSafetyPattern@{fgkSafetyPattern}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}const char {\bf Ali\-HLTData\-Buffer::fgk\-Safety\-Pattern} = \{0x28, 0x63, 0x29, 0x4d, 0x52, 0x49, 0x43, 0x48, 0x54, 0x45, 0x52, 0x20, 0x32, 0x30, 0x30, 0x37\}\hspace{0.3cm}{\tt  [static, private]}}\label{classAliHLTDataBuffer_v6}


the safety pattern 

Definition at line 87 of file Ali\-HLTData\-Buffer.cxx.

Referenced by Create\-Raw\-Buffer(), and Release\-Raw\-Buffer().\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!fgkSafetyPatternSize@{fgkSafetyPatternSize}}
\index{fgkSafetyPatternSize@{fgkSafetyPatternSize}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}const Int\_\-t {\bf Ali\-HLTData\-Buffer::fgk\-Safety\-Pattern\-Size} = 16\hspace{0.3cm}{\tt  [static, private]}}\label{classAliHLTDataBuffer_v5}


size of the safety pattern 

Definition at line 86 of file Ali\-HLTData\-Buffer.cxx.

Referenced by Release\-Raw\-Buffer().\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!fgLogging@{fgLogging}}
\index{fgLogging@{fgLogging}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf Ali\-HLTLogging} {\bf Ali\-HLTData\-Buffer::fg\-Logging}\hspace{0.3cm}{\tt  [static, private]}}\label{classAliHLTDataBuffer_v4}


global instance to HLT logging class for static methods 

Definition at line 85 of file Ali\-HLTData\-Buffer.cxx.

Referenced by Create\-Raw\-Buffer(), Delete\-Raw\-Buffers(), and Release\-Raw\-Buffer().\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!fgMargin@{fgMargin}}
\index{fgMargin@{fgMargin}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf Ali\-HLTUInt32\_\-t} {\bf Ali\-HLTData\-Buffer::fg\-Margin} = 1024\hspace{0.3cm}{\tt  [static, private]}}\label{classAliHLTDataBuffer_v3}


determines the raw buffer size margin at buffer requests 

Definition at line 84 of file Ali\-HLTData\-Buffer.cxx.\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!fgNofInstances@{fgNofInstances}}
\index{fgNofInstances@{fgNofInstances}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int {\bf Ali\-HLTData\-Buffer::fg\-Nof\-Instances} = 0\hspace{0.3cm}{\tt  [static, private]}}\label{classAliHLTDataBuffer_v0}


Number of instances of Ali\-HLTData\-Buffer. The statice variable is incremented and decremented in the constructor/ destructor. All internal data structures are cleaned up when the last instance is exiting. 

Definition at line 81 of file Ali\-HLTData\-Buffer.cxx.

Referenced by $\sim$Ali\-HLTData\-Buffer().\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!fpBuffer@{fpBuffer}}
\index{fpBuffer@{fpBuffer}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf Ali\-HLTRaw\-Buffer}$\ast$ {\bf Ali\-HLTData\-Buffer::fp\-Buffer}\hspace{0.3cm}{\tt  [private]}}\label{classAliHLTDataBuffer_r4}




Definition at line 288 of file Ali\-HLTData\-Buffer.h.

Referenced by Get\-Target\-Buffer(), Is\-Empty(), Reset\-Data\-Buffer(), Set\-Segments(), and Subscribe().\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!fReleasedConsumers@{fReleasedConsumers}}
\index{fReleasedConsumers@{fReleasedConsumers}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}vector$<${\bf Ali\-HLTConsumer\-Descriptor}$\ast$$>$ {\bf Ali\-HLTData\-Buffer::f\-Released\-Consumers}\hspace{0.3cm}{\tt  [private]}}\label{classAliHLTDataBuffer_r3}




Definition at line 285 of file Ali\-HLTData\-Buffer.h.

Referenced by Find\-Consumer(), Get\-Nof\-Consumers(), Release(), and Reset\-Data\-Buffer().\index{AliHLTDataBuffer@{Ali\-HLTData\-Buffer}!fSegments@{fSegments}}
\index{fSegments@{fSegments}!AliHLTDataBuffer@{Ali\-HLTData\-Buffer}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}vector$<${\bf Ali\-HLTData\-Segment}$>$ {\bf Ali\-HLTData\-Buffer::f\-Segments}\hspace{0.3cm}{\tt  [private]}}\label{classAliHLTDataBuffer_r0}




Definition at line 278 of file Ali\-HLTData\-Buffer.h.

Referenced by Find\-Matching\-Data\-Segments(), Get\-Nof\-Segments(), Reset\-Data\-Buffer(), and Set\-Segments().

The documentation for this class was generated from the following files:\begin{CompactItemize}
\item 
/home/perthi/cern/aliroot/Ali\-Root\_\-head020507/HLT/BASE/{\bf Ali\-HLTData\-Buffer.h}\item 
/home/perthi/cern/aliroot/Ali\-Root\_\-head020507/HLT/BASE/{\bf Ali\-HLTData\-Buffer.cxx}\end{CompactItemize}
