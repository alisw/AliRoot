

\section{Reconstruction code}


The energy deposited by the particles in the towers produces scintillating light that is propagated with optic fibers through the different layers to APD placed at the base of the cells. The APDs amplify the signal and generate an electronic pulse shape that is stored in the raw data format. From this pulse shape, we extract the signal amplitude and the arrival time. The pulse shape is fitted during the reconstruction via a parametrized function and TMinuit, and those 2 values are extracted.

A particle produces signals in different towers (electromagnetic shower expands more than its Moli\`ere radius which is a cell size). The next step is the formation of clusters of cells that belong to the same particle, although depending on the energy, granularity, clusterization algorithm or event type, those clusters might have contributions from different particles. The default algorithm in pp collisions is a simple aggregation of neighboring cells until there is no more cells above a certain energy threshold (named {\it clusterizer V1}). In case of Pb-Pb collisions environment, where particle showers merge quite often, we apply another algorithm that aggregates cells to the clusters until reaching a cell with more energy than the precedent (named {\it clusterizer V2}). Depending on the analysis type, one might want to use one or the other clusterization type. For this reason, a re-clusterization is also possible at the analysis level. A last clusterizer is implemented, which makes 3x3 clusters. It has been used in jet analysis for instance in order to avoid biasing jet reconstruction where one is interested in the energy flow over a large area without explicit reconstruction of photon showers and where the driving consideration is that the wide clusterizer does not interfere with the jet finder. For $\pi^{0}$, $\eta$, and direct $\gamma$ analyses, {\it V2} is most likely preferable).

Once the cluster is defined, we calculate cluster parameters, shower shape parameters, that will help at the analysis level to identify each cluster as one particle type. Also, we compare the cluster position information with the propagation of tracks measured in the central barrel to the EMCAL surface, to identify the clusters generated by charged particles.

The final analysis objects, ESDs and AODs, contain all the cluster and cell basic informations allowing to redo the clusterization if needed at the analysis level.

%The class AliReconstruction manages this part. This step can
%begin either from the Digits or from the Raw data. We can distinguish
%different steps described in the following sections. 


\subsection{Offline data base access}

How to create explained OCDB/OADB section.

\subsubsection{Energy calibration}

\subsubsection{Bad channels - Marie, Alexis}

\subsubsection{Alignment - Marco}

\subsection{Raw data fitting: from ADC sample to digits - David}

As also discussed in Sec.~\ref{sec:simu_raw}, the recorded Raw data consists
of instead a series of so-called time samples with 10-bit ADC counts per channel. 
Each time bin is 100 ns wide, corresponding to a 10 MHz readout.
The expected signal (Gamma-2) shape is described e.g. in the AliEMCALRawResponse class,
in the RawResponseFunction method.
The reconstruction from Raw data to Digits is done in the AliEMCALRawUtils class,
Raw2Digits method.
The Raw ADC time samples data is kept in AliCaloBunchInfo objects, which are given
as input to an AliCaloRawAnalyzer object, which returns the signal amplitude and time
information (in the form of an AliCaloFitResults object).
There are several different AloCaloRawAnalyzer versions, which can be selected via
AliEMCALRawUtils::SetFittingAlgorithm(). They are:

\begin{itemize}
 \item kStandard:
   AliCaloRawAnalyzerKStandard, which is a (slower but simple) Gamma-2 fit implementation.
 \item  kFastFit: 
   AliCaloRawAnalyzerFastFit, which is a faster Gamma-2 fit implementation from Aleksei Pavlinov.
 \item kNeuralNet:
   AliCaloRawAnalyzerNN, which is a neural network implementation from Paola La Rocca and Franco Riggi.
 \item kPeakFinder:
   AliCaloRawAnalyzerPeakFinder, which is a fast (parameterized vector operations) implementation from Per Thomas Hille. 
 \item kCrude:
   AliCaloRawAnalyzerCrude, which is the simplest possible algorithm: just take the maximum ADC value as the signal amplitude.
 \item kFakeAltro:
   AliCaloRawAnalyzerFakeALTRO, which is an algorithm intended for the Trigger/TRU raw data analysis, i.e. not for the regular FEE or cell/tower data.
\end{itemize}



\subsection{Clusterization: From digits to clusters - Adam}

\input{clusterization}



\subsection{Cluster-Track matching - Rongrong, Shingo, Michael}

Even though EMCal is intended to measure the energy of particles that interact with EMCal via electromagnetic showering, e.g. photons and electrons, charged hadrons can also deposit energy in EMCal, most commonly via minimum ionization, but also via nuclear interactions generating hadronic showers. In the analysis where the distinction between hadroic and electromagnetic showers is necessary, cluster-track matching is often used to meet this requirement. 

The main method used to extrapolate tracks in the ALICE software framework is:

\begin{DDbox}{\linewidth}
\begin{lstlisting}
 static Bool_t PropagateTrackToBxByBz(AliExternalTrackParam *track, Double_t x, Double_t m,Double_t maxStep, Bool_t rotateTo=kTRUE, Double_t maxSnp=0.8,Int_t sign=0, Bool_t addTimeStep=kFALSE); 
\end{lstlisting}
\end{DDbox}
which takes the following arguments: {\it ``track''} stores all the information of the starting point for the extrapolation; {\it ``x''} is the coordinate of the destination plane in the local coordinate system; {\it ``m''} is the mass assumption for the track; {\it ``maxStep''} is the step size used in the extrapolation. This method extrapolates the track trajectory to a destination plane in a magnetic field, taking into account the energy loss of the tracks when going through detector materials. However, the energy loss model is tuned for charged hadrons, so it does not work very well for electrons or positions whose primary energy loss process is bremsstrahlung.

For EMCal, the track-cluster matching is done by default in the reconstruction chain and the code is implemented in:

\begin{DDbox}{\linewidth}
\begin{lstlisting}
 AliEMCALTracker::PropagateBack(AliESDEvent* esd)
\end{lstlisting}
\end{DDbox}

The logic of the matching procedure is the following:
\begin{itemize}
\item Check wheter TPC is available in DAQ/reco. See AliEMCALTracker::LoadClusters(). In case there is no TPC, ITS specific extrapolation will be used.
\item Find all the EMCal clusters in the event. See AliEMCALTracker::LoadClusters().
\item Find all the good tracks in the event. See AliEMCALTracker:: LoadTracks(). Several cuts are applied to select good tracks
	\begin{itemize}
	\item Minimum $p_{\rm{T}}$ cut, which can be set during the reconstruction.
	\item Cut on number of TPC clusters, which can be set during the reconstruction. This specific cut is avoided in case there is only ITS available in reconstruction. 	
	\item $|\eta|<0.8$ and $20^{\circ} < \varphi < 120^{\circ} $. These fiducial cuts are hard coded since tracks out of this range should never make it to EMCal. 
	\end{itemize}
\item For each good track, find the nearest cluster as matched if their residuals fall within the cuts. See AliEMCALTracker::FindMatchedCluster(), which follows the following steps:
	\begin{itemize}
	\item Get the starting point: if the {\it friendTrack} is available, use the last point on the TPC. Otherwise, use the point at the inner wall of the TPC.
	\item If only ITS tracks are available in reconstruction, the propagation will use the track information from the vertex.  	   
	\item Extrapolate tracks to the EMCal surface at 430 cm, and apply fiducial cuts on the extrapolated points: $|\eta|<0.75$ and $70^{\circ} < \varphi < 190^{\circ} $. The step size in the extrapolation can be set in the reconstruction, and the default value is 20 cm.
	\item Extrapolate tracks further, with 5 cm step size, to the positions of all the EMCal clusters which are in the vicinity of the extrapolated points from last step. Then the distance between extrapolated tracks to the clusters are calculated, and the nearest cluster is assigned as matched if the residuals fall within cuts. By fitting the distributions of the residuals using Gaussian functions, we can choose to cut on $N\sigma$ of the residuals.To further improve the matching performance, $p_{\rm{T}}$ and charge dependent cuts can be used. 
	\end{itemize}
\end{itemize}



\subsection{How to execute the reconstruction}

Executing the reconstruction is very similar to the simulation case, see the macro TestEMCALReconstruction.C (a bit more detailed than the one in \$ALICE\_ROOT/EMCAL/macros) :

\begin{DDbox}{\linewidth}
\begin{lstlisting}
void TestEMCALReconstruction() {

TString detector=``EMCAL TPC'';//Same function as in Simulation.C  
// TString detector=``EMCAL ITS''; if user wants ITS tracking to be used.

AliReconstruction rec; //Create reconstruction object 

//Making Tracking 
rec.SetRunTracking(detector) ;

//Particle Reconstruction. Make Rec Points 
rec.SetRunReconstruction(detector); 

//read RAW data. Give directory where raw data is stored
//rec.SetInput(``RawDataDirectory/raw.root");

//Make vertex finder 
rec.SetRunVertexFinder(kFALSE) ; // false only if the tracking detectors are not included.

//Fill ESD file with RecPoints information. 
rec.SetFillESD(detector) ; 

//Run Reconstruction 
rec.Run() ;
}
\end{lstlisting}
\end{DDbox}


