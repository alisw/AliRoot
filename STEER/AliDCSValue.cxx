/**************************************************************************
 * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
 *                                                                        *
 * Author: The ALICE Off-line Project.                                    *
 * Contributors are mentioned in the code where appropriate.              *
 *                                                                        *
 * Permission to use, copy, modify and distribute this software and its   *
 * documentation strictly for non-commercial purposes is hereby granted   *
 * without fee, provided that the above copyright notice appears in all   *
 * copies and that both the copyright notice and this permission notice   *
 * appear in the supporting documentation. The authors make no claims     *
 * about the suitability of this software for any purpose. It is          *
 * provided "as is" without express or implied warranty.                  *
 **************************************************************************/

/*
$Log$
Revision 1.1  2006/06/02 14:14:36  hristov
Separate library for CDB (Jan)

Revision 1.2  2006/03/07 07:52:34  hristov
New version (B.Yordanov)

Revision 1.2  2005/11/17 14:43:23  byordano
import to local CVS

Revision 1.1.1.1  2005/10/28 07:33:58  hristov
Initial import as subdirectory in AliRoot

Revision 1.1.1.1  2005/09/12 22:11:40  byordano
SHUTTLE package

Revision 1.2  2005/08/30 10:53:23  byordano
some more descriptions added

*/

//
// This class represents the value(s) of
// a DCS data point at a given timestamp.
// It stores different data types, the current implementation has a member for all of them.
// This is definitly not efficient, but the only way to use the automatic streamers generated by ROOT.
//
// Each element of this value series has two fields:
// fValue - primitive value which represents the real measured value
// fTimestamp - timestamp when the measurement was made
//

#include "AliDCSValue.h"

#include "TTimeStamp.h"
#include <TString.h>

ClassImp(AliDCSValue)

AliDCSValue::AliDCSValue() : TObject()
{
  // default constructor

  Init();
}

AliDCSValue::AliDCSValue(Bool_t value, UInt_t timeStamp) : TObject()
{
  // constructor

  Init();

  fTimeStamp = timeStamp;

  fType = kBool;
  fBool = value;
}

AliDCSValue::AliDCSValue(Char_t value, UInt_t timeStamp) : TObject()
{
  // constructor

  Init();

  fTimeStamp = timeStamp;

  fType = kChar;
  fChar = value;
}

AliDCSValue::AliDCSValue(Int_t value, UInt_t timeStamp) : TObject()
{
  // constructor

  Init();

  fTimeStamp = timeStamp;

  fType = kInt;
  fInt = value;
}

AliDCSValue::AliDCSValue(UInt_t value, UInt_t timeStamp) : TObject()
{
  // constructor

  Init();

  fTimeStamp = timeStamp;

  fType = kUInt;
  fUInt = value;
}

AliDCSValue::AliDCSValue(Float_t value, UInt_t timeStamp) : TObject()
{
  // constructor

  Init();

  fTimeStamp = timeStamp;

  fType = kFloat;
  fFloat = value;
}

AliDCSValue::AliDCSValue(Int_t size, Bool_t* vals, UInt_t timeStamp) : TObject()
{
  // constructor

  Init();

  fTimeStamp = timeStamp;

  fType = kDynBool;
  fBoolPtr = vals;
  fLength = size;
}

AliDCSValue::AliDCSValue(Int_t size, Char_t* vals, UInt_t timeStamp) : TObject()
{
  // constructor

  Init();

  fTimeStamp = timeStamp;

  fType = kDynChar;
  fCharPtr = vals;
  fLength = size;
}

AliDCSValue::AliDCSValue(Int_t size, Int_t* vals, UInt_t timeStamp) : TObject()
{
  // constructor

  Init();

  fTimeStamp = timeStamp;

  fType = kDynInt;
  fIntPtr = vals;
  fLength = size;
}

AliDCSValue::AliDCSValue(Int_t size, UInt_t* vals, UInt_t timeStamp) : TObject()
{
  // constructor

  Init();

  fTimeStamp = timeStamp;

  fType = kDynUInt;
  fUIntPtr = vals;
  fLength = size;
}

AliDCSValue::AliDCSValue(Int_t size, Float_t* vals, UInt_t timeStamp) : TObject()
{
  // constructor

  Init();

  fTimeStamp = timeStamp;

  fType = kDynFloat;
  fFloatPtr = vals;
  fLength = size;
}

AliDCSValue::AliDCSValue(const AliDCSValue& c) : TObject(c)
{
  // copy constructor

  ((AliDCSValue &)c).Copy(*this);
}

void AliDCSValue::Init()
{
  // init helper, that initializes everything to 0

  fType = kInvalid;

  fBool = kFALSE;
  fChar = 0;
  fInt = 0;
  fUInt = 0;
  fFloat = 0;

  fLength = 0;

  fBoolPtr = 0;
  fCharPtr = 0;
  fIntPtr = 0;
  fUIntPtr = 0;
  fFloatPtr = 0;

  fTimeStamp = 0;
}

AliDCSValue::~AliDCSValue()
{
  // destructor

  if (fBoolPtr)
  {
    delete[] fBoolPtr;
    fBoolPtr = 0;
  }

  if (fCharPtr)
  {
    delete[] fCharPtr;
    fCharPtr = 0;
  }

  if (fIntPtr)
  {
    delete[] fIntPtr;
    fIntPtr = 0;
  }

  if (fUIntPtr)
  {
    delete[] fUIntPtr;
    fUIntPtr = 0;
  }

  if (fFloatPtr)
  {
    delete[] fFloatPtr;
    fFloatPtr = 0;
  }
}

AliDCSValue &AliDCSValue::operator=(const AliDCSValue &c)
{
  // assigment operator

  if (this != &c) 
    ((AliDCSValue &) c).Copy(*this);

  return *this;
}

void AliDCSValue::Copy(TObject& c) const
{
  // copy function

  AliDCSValue& target = (AliDCSValue &) c;

  target.Init();

  target.fType = fType;

  target.fBool = fBool;
  target.fChar = fChar;
  target.fInt = fInt;
  target.fUInt = fUInt;
  target.fFloat = fFloat;

  target.fLength = fLength;

  if (fLength > 0)
  {
    if (fBoolPtr)
    {
      target.fBoolPtr = new Bool_t[fLength];
      for (UInt_t i=0; i<fLength; ++i)
        target.fBoolPtr[i] = fBoolPtr[i];
    }
    if (fCharPtr)
    {
      target.fCharPtr = new Char_t[fLength];
      for (UInt_t i=0; i<fLength; ++i)
        target.fCharPtr[i] = fCharPtr[i];
    }
    if (fIntPtr)
    {
      target.fIntPtr = new Int_t[fLength];
      for (UInt_t i=0; i<fLength; ++i)
        target.fIntPtr[i] = fIntPtr[i];
    }
    if (fUIntPtr)
    {
      target.fUIntPtr = new UInt_t[fLength];
      for (UInt_t i=0; i<fLength; ++i)
        target.fUIntPtr[i] = fUIntPtr[i];
    }
    if (fFloatPtr)
    {
      target.fFloatPtr = new Float_t[fLength];
      for (UInt_t i=0; i<fLength; ++i)
        target.fFloatPtr[i] = fFloatPtr[i];
    }
  }

  target.fTimeStamp = fTimeStamp;
}

Int_t AliDCSValue::GetSize() const
{
  // returns size in bytes of stored structure

  Int_t size = sizeof(fTimeStamp);

  switch (fType)
  {
    case kBool:  size += sizeof(Bool_t);  break;
    case kChar:  size += sizeof(Char_t);  break;
    case kInt:   size += sizeof(Int_t);   break;
    case kUInt:  size += sizeof(UInt_t);  break;
    case kFloat: size += sizeof(Float_t); break;

    case kDynBool:  size += fLength * sizeof(Bool_t);   break;
    case kDynChar:  size += fLength * sizeof(Char_t);   break;
    case kDynInt:   size += fLength * sizeof(Int_t);    break;
    case kDynUInt:  size += fLength * sizeof(UInt_t);   break;
    case kDynFloat: size += fLength * sizeof(Float_t);  break;

    case kInvalid: break;
  }

  return size;
}

Bool_t AliDCSValue::IsDynamic(Type type)
{
  // return if the given type is dynamic

  switch (type)
  {
    case kDynBool:
    case kDynChar:
    case kDynInt:
    case kDynUInt:
    case kDynFloat: return kTRUE; break;

    default: return kFALSE; break;
  }
}

const Char_t* AliDCSValue::ToString() const
{
  TString str;

  switch (fType)
  {
    case kBool:  str.Form("%d", fBool);  break;
    case kChar:  str.Form("%d", fChar);  break;
    case kInt:   str.Form("%d", fInt);  break;
    case kUInt:  str.Form("%d", fUInt);  break;
    case kFloat: str.Form("%f", fFloat);  break;

    case kDynBool:  for (UInt_t i=0; i<fLength; ++i) str += Form("%d ", fBoolPtr[i]); break;
    case kDynChar:  for (UInt_t i=0; i<fLength; ++i) str += Form("%d ", fCharPtr[i]); break;
    case kDynInt:   for (UInt_t i=0; i<fLength; ++i) str += Form("%d ", fIntPtr[i]); break;
    case kDynUInt:  for (UInt_t i=0; i<fLength; ++i) str += Form("%d ", fUIntPtr[i]); break;
    case kDynFloat: for (UInt_t i=0; i<fLength; ++i) str += Form("%f ", fFloatPtr[i]); break;

    case kInvalid: break;
  }

  return Form("%s Timestamp: %s", str.Data(), TTimeStamp(fTimeStamp).AsString());
}
